<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://jjungs-lee.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://jjungs-lee.github.io//" rel="alternate" type="text/html" /><updated>2022-03-03T14:19:37+00:00</updated><id>https://jjungs-lee.github.io//feed.xml</id><title type="html">Yes! I Take IT</title><subtitle>This is JJung's Website.</subtitle><author><name>JJungs-lee</name></author><entry><title type="html">Rust by Example : 0. Introduction</title><link href="https://jjungs-lee.github.io//rust/0.Rust-By-Exaple" rel="alternate" type="text/html" title="Rust by Example : 0. Introduction" /><published>2022-03-02T00:00:00+00:00</published><updated>2022-03-02T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//rust/0.Rust%20By%20Exaple</id><content type="html" xml:base="https://jjungs-lee.github.io//rust/0.Rust-By-Exaple"><![CDATA[<p>If you’re studying rust, it’s very helpful to follow the examples. I’m going to try to study it. :)</p>

<p>Rust is a modern systems programming language focusing on safety, speed, and concurrency. It accomplishes these goals by being memory safe without using garbage collection.</p>

<p>Rust by Example (RBE) is a collection of runnable examples that illustrate various Rust concepts and standard libraries. 
To get even more out of these examples, don’t forget to <a href="https://www.rust-lang.org/tools/install">install Rust locally</a> and check out the <a href="https://doc.rust-lang.org/std/">official docs</a>. Additionally for the curious, you can also <a href="https://github.com/rust-lang/rust-by-example">check out the source code for this site</a>.
Now let’s begin!</p>

<h2 id="link">link</h2>
<ul>
  <li>[1. Hello World] - Start with a traditional Hello World program.</li>
  <li>[2. Primitives] - Learn about signed integers, unsigned integers and other primitives.</li>
  <li>[3. Custom Types] - struct and enum.</li>
  <li>[4. Variable Bindings] - mutable bindings, scope, shadowing.</li>
  <li>[5. Types] - Learn about changing and defining types.</li>
  <li>[6. Conversion]</li>
  <li>[7. Expressions]</li>
  <li>[8. Flow of Control] - if/else, for, and others.</li>
  <li>[9. Functions] - Learn about Methods, Closures and High Order Functions.</li>
  <li>[10. Modules] - Organize code using modules</li>
  <li>[11. Crates] - A crate is a compilation unit in Rust. Learn to create a library.</li>
  <li>[12. Cargo] - Go through some basic features of the official Rust package management tool.</li>
  <li>[13. Attributes] - An attribute is metadata applied to some module, crate or item.</li>
  <li>[14. Generics]  - Learn about writing a function or data type which can work for multiple types of arguments.</li>
  <li>[15. Scoping rules] - Scopes play an important part in ownership, borrowing, and lifetimes.</li>
  <li>[16. Traits] - A trait is a collection of methods defined for an unknown type: Self</li>
  <li>[17. Macros]</li>
  <li>[18. Error handling] - Learn Rust way of handling failures.</li>
  <li>[19. Std library types] - Learn about some custom types provided by std library.</li>
  <li>[20. Std misc] - More custom types for file handling, threads.</li>
  <li>[21. Testing] - All sorts of testing in Rust.</li>
  <li>[22. Unsafe Operations]</li>
  <li>[23. Compatibility]</li>
  <li>[24. Meta] - Documentation, Benchmarking.</li>
</ul>

<hr />
<p>[Reference] <br />
eng ver : <a href="https://doc.rust-lang.org/rust-by-example/index.html">https://doc.rust-lang.org/rust-by-example/index.html</a></p>]]></content><author><name>JJungs-lee</name></author><category term="RUST by Example" /><category term="Rust" /><category term="Example" /><summary type="html"><![CDATA[If you’re studying rust, it’s very helpful to follow the examples. I’m going to try to study it. :)]]></summary></entry><entry><title type="html">Rust by Example : 1. Hello World</title><link href="https://jjungs-lee.github.io//rust/1.Hello-World" rel="alternate" type="text/html" title="Rust by Example : 1. Hello World" /><published>2022-03-02T00:00:00+00:00</published><updated>2022-03-02T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//rust/1.Hello%20World</id><content type="html" xml:base="https://jjungs-lee.github.io//rust/1.Hello-World"><![CDATA[<p>This is the source code of the traditional Hello World program.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This is the main function</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Statements here are executed when the compiled binary is called</span>

  <span class="c1">// Print text to the console</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">println!</code> is a <a href="https://doc.rust-lang.org/rust-by-example/macros.html">macro</a> that prints text to the console.</p>

<p>A binary can be generated using the Rust compiler: <code class="language-plaintext highlighter-rouge">rustc</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rustc hello.rs
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">rustc</code> will produce a <code class="language-plaintext highlighter-rouge">hello</code> binary that can be executed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./hello
Hello World!
</code></pre></div></div>
<h3 id="activity">Activity</h3>
<p>Click ‘Run’ above to see the expected output. Next, add a new line with a second <code class="language-plaintext highlighter-rouge">println!</code> macro so that the output shows:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello World!  
I'm a Rustacean!
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// answer code</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"I'm a Rustacean!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="11-comments">1.1 Comments</h2>

<p>Any program requires comments, and Rust supports a few different varieties:</p>

<ul>
  <li>Regular comments which are ignored by the compiler:
    <ul>
      <li>// Line comments which go to the end of the line.</li>
      <li>/* Block comments which go to the closing delimiter. */</li>
    </ul>
  </li>
  <li>Doc comments which are parsed into HTML library documentation:
    <ul>
      <li>/// Generate library docs for the following item.</li>
      <li>//! Generate library docs for the enclosing item.</li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// This is an example of a line comment</span>
  <span class="c1">// There are two slashes at the beginning of the line</span>
  <span class="c1">// And nothing written inside these will be read by the compiler</span>

  <span class="c1">// println!("Hello, world!");</span>

  <span class="c1">// Run it. See? Now try deleting the two slashes, and run it again.</span>

  <span class="cm">/* 
    * This is another type of comment, a block comment. In general,
    * line comments are the recommended comment style. But
    * block comments are extremely useful for temporarily disabling
    * chunks of code. /* Block comments can be /* nested, */ */
    * so it takes only a few keystrokes to comment out everything
    * in this main() function. /*/*/* Try it yourself! */*/*/
    */</span>

  <span class="cm">/*
  Note: The previous column of `*` was entirely for style. There's
  no actual need for it.
  */</span>

  <span class="c1">// You can manipulate expressions more easily with block comments</span>
  <span class="c1">// than with line comments. Try deleting the comment delimiters</span>
  <span class="c1">// to change the result:</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="cm">/* 90 + */</span> <span class="mi">5</span><span class="p">;</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Is `x` 10 or 100? x = {}"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>
<p>See also: <br />
<a href="https://doc.rust-lang.org/rust-by-example/meta/doc.html">Library documentation</a></p>

<h2 id="12-formatted-print">1.2 Formatted print</h2>
<p>Printing is handled by a series of <code class="language-plaintext highlighter-rouge">macros</code> defined in <code class="language-plaintext highlighter-rouge">std::fmt</code> some of which include:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">format!</code>: write formatted text to <code class="language-plaintext highlighter-rouge">String</code></li>
  <li><code class="language-plaintext highlighter-rouge">print!</code>: same as <code class="language-plaintext highlighter-rouge">format!</code> but the text is printed to the console (io::stdout).</li>
  <li><code class="language-plaintext highlighter-rouge">println!</code>: same as <code class="language-plaintext highlighter-rouge">print!</code> but a newline is appended.</li>
  <li><code class="language-plaintext highlighter-rouge">eprint!</code>: same as <code class="language-plaintext highlighter-rouge">format!</code> but the text is printed to the standard error (io::stderr).</li>
  <li><code class="language-plaintext highlighter-rouge">eprintln!</code>: same as <code class="language-plaintext highlighter-rouge">eprint!</code> but a newline is appended.</li>
</ul>

<p>All parse text in the same fashion. As a plus, Rust checks formatting correctness at compile time.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// In general, the `{}` will be automatically replaced with any</span>
  <span class="c1">// arguments. These will be stringified.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{} days"</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>

  <span class="c1">// Without a suffix, 31 becomes an i32. You can change what type 31 is</span>
  <span class="c1">// by providing a suffix. The number 31i64 for example has the type i64.</span>

  <span class="c1">// There are various optional patterns this works with. Positional</span>
  <span class="c1">// arguments can be used.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{0}, this is {1}. {1}, this is {0}"</span><span class="p">,</span> <span class="s">"Alice"</span><span class="p">,</span> <span class="s">"Bob"</span><span class="p">);</span>

  <span class="c1">// As can named arguments.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{subject} {verb} {object}"</span><span class="p">,</span>
            <span class="n">object</span><span class="o">=</span><span class="s">"the lazy dog"</span><span class="p">,</span>
            <span class="n">subject</span><span class="o">=</span><span class="s">"the quick brown fox"</span><span class="p">,</span>
            <span class="n">verb</span><span class="o">=</span><span class="s">"jumps over"</span><span class="p">);</span>

  <span class="c1">// Special formatting can be specified after a `:`.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{} of {:b} people know binary, the other half doesn't"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

  <span class="c1">// You can right-align text with a specified width. This will output</span>
  <span class="c1">// "     1". 5 white spaces and a "1".</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{number:&gt;width$}"</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">6</span><span class="p">);</span>

  <span class="c1">// You can pad numbers with extra zeroes. This will output "000001".</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{number:0&gt;width$}"</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">6</span><span class="p">);</span>

  <span class="c1">// Rust even checks to make sure the correct number of arguments are</span>
  <span class="c1">// used.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"My name is {0}, {1} {0}"</span><span class="p">,</span> <span class="s">"Bond"</span><span class="p">);</span>
  <span class="c1">// FIXME ^ Add the missing argument: "James"</span>

  <span class="c1">// Create a structure named `Structure` which contains an `i32`.</span>
  <span class="nd">#[allow(dead_code)]</span>
  <span class="k">struct</span> <span class="nf">Structure</span><span class="p">(</span><span class="nb">i32</span><span class="p">);</span>

  <span class="c1">// However, custom types such as this structure require more complicated</span>
  <span class="c1">// handling. This will not work.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"This struct `{}` won't print..."</span><span class="p">,</span> <span class="nf">Structure</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
  <span class="c1">// FIXME ^ Comment out this line.</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">std::fmt</code> contains many <code class="language-plaintext highlighter-rouge">traits</code> which govern the display of text. 
The base form of two important ones are listed below:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fmt::Debug</code>: Uses the <code class="language-plaintext highlighter-rouge">{:?}</code> marker. Format text for debugging purposes.</li>
  <li><code class="language-plaintext highlighter-rouge">fmt::Display</code>: Uses the <code class="language-plaintext highlighter-rouge">{}</code> marker. Format text in a more elegant, user friendly fashion.
Here, we used <code class="language-plaintext highlighter-rouge">fmt::Display</code> because the std library provides implementations for these types. To print text for custom types, more steps are required.</li>
</ul>

<p>Implementing the fmt::Display trait automatically implements the <code class="language-plaintext highlighter-rouge">ToString</code> trait which allows us to <code class="language-plaintext highlighter-rouge">convert</code> the type to <code class="language-plaintext highlighter-rouge">String</code>.</p>

<h3 id="activities">Activities</h3>
<ul>
  <li>Fix the two issues in the above code (see FIXME) so that it runs without error.</li>
  <li>Add a <code class="language-plaintext highlighter-rouge">println!</code> macro call that prints: <code class="language-plaintext highlighter-rouge">Pi is roughly 3.142</code> by controlling the number of decimal places shown. For the purposes of this exercise, use <code class="language-plaintext highlighter-rouge">let pi = 3.141592</code> as an estimate for pi. (Hint: you may need to check the <code class="language-plaintext highlighter-rouge">std::fmt</code> documentation for setting the number of decimals to display)</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// #1 FIXME -&gt; println!("My name is {0}, {1} {0}", "Bond");</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"My name is {0}, {1} {0}"</span><span class="p">,</span> <span class="s">"Bond"</span><span class="p">,</span> <span class="s">"James"</span><span class="p">);</span>

  <span class="c1">// #2 FIXME -&gt; comment out </span>
  <span class="c1">// println!("This struct `{}` won't print...", Structure(3));</span>

  <span class="c1">// #3 Add a println! macro call that prints</span>
  <span class="k">let</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.141592</span><span class="p">;</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Pi is roughly {0:.3}"</span><span class="p">,</span> <span class="n">pi</span><span class="p">);</span>
</code></pre></div></div>
<p>See also: <br />
<a href="https://doc.rust-lang.org/std/fmt/">std::fmt</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/macros.html">macros</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/custom_types/structs.html">struct</a>, and 
<a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">traits</a></p>

<h3 id="121-debug">1.2.1 Debug</h3>
<p>All types which want to use <code class="language-plaintext highlighter-rouge">std::fmt</code> formatting <code class="language-plaintext highlighter-rouge">traits</code> require an implementation to be printable. 
Automatic implementations are only provided for types such as in the <code class="language-plaintext highlighter-rouge">std</code> library. 
All others <em>must</em> be manually implemented somehow.</p>

<p>The <code class="language-plaintext highlighter-rouge">fmt::Debug</code> <code class="language-plaintext highlighter-rouge">trait</code> makes this very straightforward. <em>All</em> types can <code class="language-plaintext highlighter-rouge">derive</code> (automatically create) the <code class="language-plaintext highlighter-rouge">fmt::Debug</code> implementation. 
This is not true for <code class="language-plaintext highlighter-rouge">fmt::Display</code> which must be manually implemented.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This structure cannot be printed either with `fmt::Display` or</span>
<span class="c1">// with `fmt::Debug`.</span>
<span class="k">struct</span> <span class="nf">UnPrintable</span><span class="p">(</span><span class="nb">i32</span><span class="p">);</span>

<span class="c1">// The `derive` attribute automatically creates the implementation</span>
<span class="c1">// required to make this `struct` printable with `fmt::Debug`.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nf">DebugPrintable</span><span class="p">(</span><span class="nb">i32</span><span class="p">);</span>
</code></pre></div></div>

<p>All <code class="language-plaintext highlighter-rouge">std</code> library types are automatically printable with <code class="language-plaintext highlighter-rouge">{:?}</code> too:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Derive the `fmt::Debug` implementation for `Structure`. `Structure`</span>
<span class="c1">// is a structure which contains a single `i32`.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nf">Structure</span><span class="p">(</span><span class="nb">i32</span><span class="p">);</span>

<span class="c1">// Put a `Structure` inside of the structure `Deep`. Make it printable</span>
<span class="c1">// also.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nf">Deep</span><span class="p">(</span><span class="n">Structure</span><span class="p">);</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Printing with `{:?}` is similar to with `{}`.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?} months in a year."</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{1:?} {0:?} is the {actor:?} name."</span><span class="p">,</span>
            <span class="s">"Slater"</span><span class="p">,</span>
            <span class="s">"Christian"</span><span class="p">,</span>
            <span class="n">actor</span><span class="o">=</span><span class="s">"actor's"</span><span class="p">);</span>

  <span class="c1">// `Structure` is printable!</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Now {:?} will print!"</span><span class="p">,</span> <span class="nf">Structure</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
  
  <span class="c1">// The problem with `derive` is there is no control over how</span>
  <span class="c1">// the results look. What if I want this to just show a `7`?</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Now {:?} will print!"</span><span class="p">,</span> <span class="nf">Deep</span><span class="p">(</span><span class="nf">Structure</span><span class="p">(</span><span class="mi">7</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So <code class="language-plaintext highlighter-rouge">fmt::Debug</code> definitely makes this printable but sacrifices some elegance. Rust also provides “pretty printing” with <code class="language-plaintext highlighter-rouge">{:#?}</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Person</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
  <span class="n">age</span><span class="p">:</span> <span class="nb">u8</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Peter"</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">peter</span> <span class="o">=</span> <span class="n">Person</span> <span class="p">{</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="p">};</span>

  <span class="c1">// Pretty print</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{:#?}"</span><span class="p">,</span> <span class="n">peter</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>One can manually implement <code class="language-plaintext highlighter-rouge">fmt::Display</code> to control the display.</p>

<p>See also: <br />
<a href="https://doc.rust-lang.org/reference/attributes.html">attributes</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html">derive</a>, 
<a href="https://doc.rust-lang.org/std/fmt/">std::fmt</a>, and 
<a href="https://doc.rust-lang.org/rust-by-example/custom_types/structs.html">struct</a></p>

<h3 id="122-display">1.2.2 Display</h3>
<p><code class="language-plaintext highlighter-rouge">fmt::Debug</code> hardly looks compact and clean, so it is often advantageous to customize the output appearance. This is done by manually implementing <code class="language-plaintext highlighter-rouge">fmt::Display</code>, which uses the <code class="language-plaintext highlighter-rouge">{}</code> print marker. Implementing it looks like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Import (via `use`) the `fmt` module to make it available.</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>

<span class="c1">// Define a structure for which `fmt::Display` will be implemented. This is</span>
<span class="c1">// a tuple struct named `Structure` that contains an `i32`.</span>
<span class="k">struct</span> <span class="nf">Structure</span><span class="p">(</span><span class="nb">i32</span><span class="p">);</span>

<span class="c1">// To use the `{}` marker, the trait `fmt::Display` must be implemented</span>
<span class="c1">// manually for the type.</span>
<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Structure</span> <span class="p">{</span>
    <span class="c1">// This trait requires `fmt` with this exact signature.</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="c1">// Write strictly the first element into the supplied output</span>
        <span class="c1">// stream: `f`. Returns `fmt::Result` which indicates whether the</span>
        <span class="c1">// operation succeeded or failed. Note that `write!` uses syntax which</span>
        <span class="c1">// is very similar to `println!`.</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">fmt::Display</code> may be cleaner than <code class="language-plaintext highlighter-rouge">fmt::Debug</code> but this presents a problem for the <code class="language-plaintext highlighter-rouge">std</code> library. 
How should ambiguous types be displayed? For example, if the <code class="language-plaintext highlighter-rouge">std</code> library implemented a single style for all <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>, what style should it be? Would it be either of these two?</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Vec&lt;path&gt;</code> : <code class="language-plaintext highlighter-rouge">/:/etc:/home/username:/bin</code> (split on <code class="language-plaintext highlighter-rouge">:</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">Vec&lt;number&gt;</code> : <code class="language-plaintext highlighter-rouge">1,2,3</code> (split on <code class="language-plaintext highlighter-rouge">,</code>)</li>
</ul>

<p>No, because there is no ideal style for all types and the <code class="language-plaintext highlighter-rouge">std</code> library doesn’t presume to dictate one. 
<code class="language-plaintext highlighter-rouge">fmt::Display</code> is not implemented for <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> or for any other generic containers.
 <code class="language-plaintext highlighter-rouge">fmt::Debug</code> must then be used for these generic cases.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span> <span class="c1">// Import `fmt`</span>

<span class="c1">// A structure holding two numbers. `Debug` will be derived so the results can</span>
<span class="c1">// be contrasted with `Display`.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nf">MinMax</span><span class="p">(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">);</span>

<span class="c1">// Implement `Display` for `MinMax`.</span>
<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">MinMax</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
      <span class="c1">// Use `self.number` to refer to each positional data point.</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({}, {})"</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="p">,</span> <span class="k">self</span><span class="na">.1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Define a structure where the fields are nameable for comparison.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Point2D</span> <span class="p">{</span>
  <span class="n">x</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
  <span class="n">y</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Similarly, implement `Display` for `Point2D`</span>
<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Point2D</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
      <span class="c1">// Customize so only `x` and `y` are denoted.</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"x: {}, y: {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span> <span class="k">self</span><span class="py">.y</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">minmax</span> <span class="o">=</span> <span class="nf">MinMax</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"Compare structures:"</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Display: {}"</span><span class="p">,</span> <span class="n">minmax</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Debug: {:?}"</span><span class="p">,</span> <span class="n">minmax</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">big_range</span> <span class="o">=</span>   <span class="nf">MinMax</span><span class="p">(</span><span class="o">-</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">small_range</span> <span class="o">=</span> <span class="nf">MinMax</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"The big range is {big} and the small is {small}"</span><span class="p">,</span>
            <span class="n">small</span> <span class="o">=</span> <span class="n">small_range</span><span class="p">,</span>
            <span class="n">big</span> <span class="o">=</span> <span class="n">big_range</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">point</span> <span class="o">=</span> <span class="n">Point2D</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">3.3</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">7.2</span> <span class="p">};</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"Compare points:"</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Display: {}"</span><span class="p">,</span> <span class="n">point</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Debug: {:?}"</span><span class="p">,</span> <span class="n">point</span><span class="p">);</span>

  <span class="c1">// Error. Both `Debug` and `Display` were implemented, but `{:b}`</span>
  <span class="c1">// requires `fmt::Binary` to be implemented. This will not work.</span>
  <span class="c1">// println!("What does Point2D look like in binary: {:b}?", point);</span>
  
<span class="p">}</span>
</code></pre></div></div>
<p>So, <code class="language-plaintext highlighter-rouge">fmt::Display</code> has been implemented but <code class="language-plaintext highlighter-rouge">fmt::Binary</code> has not, and therefore cannot be used. 
<code class="language-plaintext highlighter-rouge">std::fmt</code> has many such traits and each requires its own implementation. This is detailed further in std::fmt.</p>

<h3 id="activity-1">Activity</h3>
<p>After checking the output of the above example, use the <code class="language-plaintext highlighter-rouge">Point2D</code> struct as a guide to add a <code class="language-plaintext highlighter-rouge">Complex</code> struct to the example. 
When printed in the same way, the output should be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Display: 3.3 + 7.2i
Debug: Complex { real: 3.3, imag: 7.2 }
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Add sturct and Implemnet Display trait</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Complex</span> <span class="p">{</span>
  <span class="n">real</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
  <span class="n">imag</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Complex</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{} + {}i"</span><span class="p">,</span> <span class="k">self</span><span class="py">.real</span><span class="p">,</span> <span class="k">self</span><span class="py">.imag</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">complex</span> <span class="o">=</span> <span class="n">Complex</span> <span class="p">{</span> <span class="n">real</span><span class="p">:</span> <span class="mf">3.3</span><span class="p">,</span> <span class="n">imag</span><span class="p">:</span> <span class="mf">7.2</span> <span class="p">};</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Display: {}"</span><span class="p">,</span> <span class="n">complex</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Debug: {:?}"</span><span class="p">,</span> <span class="n">complex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>See also:
<a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html">derive</a>, 
<a href="https://doc.rust-lang.org/std/fmt/">std::fmt</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/macros.html">macros</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/custom_types/structs.html">struct</a>, 
<a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">trait</a>, and 
<a href="https://doc.rust-lang.org/rust-by-example/mod/use.html">use</a></p>

<h3 id="1221-testcase-list">1.2.2.1 Testcase: List</h3>

<p>Implementing <code class="language-plaintext highlighter-rouge">fmt::Display</code> for a structure where the elements must each be handled sequentially is tricky. 
The problem is that each <code class="language-plaintext highlighter-rouge">write!</code> generates a <code class="language-plaintext highlighter-rouge">fmt::Result</code>. Proper handling of this requires dealing with <em>all</em> the results. 
Rust provides the <code class="language-plaintext highlighter-rouge">?</code> operator for exactly this purpose.</p>

<p>Using <code class="language-plaintext highlighter-rouge">?</code> on <code class="language-plaintext highlighter-rouge">write!</code> looks like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Try `write!` to see if it errors. If it errors, return</span>
<span class="c1">// the error. Otherwise continue.</span>
<span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<p>With <code class="language-plaintext highlighter-rouge">?</code> available, implementing <code class="language-plaintext highlighter-rouge">fmt::Display</code> for a Vec is straightforward:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span> <span class="c1">// Import the `fmt` module.</span>

<span class="c1">// Define a structure named `List` containing a `Vec`.</span>
<span class="k">struct</span> <span class="nf">List</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">List</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
      <span class="c1">// Extract the value using tuple indexing,</span>
      <span class="c1">// and create a reference to `vec`.</span>
      <span class="k">let</span> <span class="n">vec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="na">.0</span><span class="p">;</span>

      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"["</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

      <span class="c1">// Iterate over `v` in `vec` while enumerating the iteration</span>
      <span class="c1">// count in `count`.</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">vec</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// For every element except the first, add a comma.</span>
          <span class="c1">// Use the ? operator to return on errors.</span>
          <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">", "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span> <span class="p">}</span>
          <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// Close the opened bracket and return a fmt::Result value.</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"]"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nf">List</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="activity-2">Activity</h3>
<p>Try changing the program so that the index of each element in the vector is also printed. The new output should look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[0: 1, 1: 2, 2: 3]
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// --snip -- </span>
  <span class="c1">// Iterate over `v` in `vec` while enumerating the iteration</span>
  <span class="c1">// count in `count`.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">vec</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}: {}"</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
      <span class="k">if</span> <span class="n">vec</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">count</span> <span class="p">{</span> <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">", "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// -- snip --</span>
</code></pre></div></div>

<p>See also:
<a href="https://doc.rust-lang.org/rust-by-example/flow_control/for.html">for</a>,
<a href="https://doc.rust-lang.org/rust-by-example/scope/borrow/ref.html">ref</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/std/result.html">Result</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/custom_types/structs.html">struct</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html">?</a>, and 
<a href="https://doc.rust-lang.org/rust-by-example/std/vec.html">vec!</a></p>

<h3 id="123-formatting">1.2.3. Formatting</h3>
<p>We’ve seen that formatting is specified via a <em>format string</em>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">format!("{}", foo)</code> -&gt; <code class="language-plaintext highlighter-rouge">"3735928559"</code></li>
  <li><code class="language-plaintext highlighter-rouge">format!("0x{:X}", foo)</code> -&gt; <code class="language-plaintext highlighter-rouge">"0xDEADBEEF"</code></li>
  <li><code class="language-plaintext highlighter-rouge">format!("0o{:o}", foo)</code> -&gt; <code class="language-plaintext highlighter-rouge">"0o33653337357"</code>
The same variable (<code class="language-plaintext highlighter-rouge">foo</code>) can be formatted differently depending on which argument type is used: <code class="language-plaintext highlighter-rouge">X</code> vs <code class="language-plaintext highlighter-rouge">o</code> vs unspecified.</li>
</ul>

<p>This formatting functionality is implemented via traits, and there is one trait for each argument type. 
The most common formatting trait is <code class="language-plaintext highlighter-rouge">Display</code>, which handles cases where the argument type is left unspecified: <code class="language-plaintext highlighter-rouge">{}</code> for instance.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">Formatter</span><span class="p">,</span> <span class="n">Display</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">City</span> <span class="p">{</span>
  <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">,</span>
  <span class="c1">// Latitude</span>
  <span class="n">lat</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
  <span class="c1">// Longitude</span>
  <span class="n">lon</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">City</span> <span class="p">{</span>
  <span class="c1">// `f` is a buffer, and this method must write the formatted string into it</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">lat_c</span> <span class="o">=</span> <span class="k">if</span> <span class="k">self</span><span class="py">.lat</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="p">{</span> <span class="sc">'N'</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="sc">'S'</span> <span class="p">};</span>
      <span class="k">let</span> <span class="n">lon_c</span> <span class="o">=</span> <span class="k">if</span> <span class="k">self</span><span class="py">.lon</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="p">{</span> <span class="sc">'E'</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="sc">'W'</span> <span class="p">};</span>

      <span class="c1">// `write!` is like `format!`, but it will write the formatted string</span>
      <span class="c1">// into a buffer (the first argument)</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}: {:.3}°{} {:.3}°{}"</span><span class="p">,</span>
              <span class="k">self</span><span class="py">.name</span><span class="p">,</span> <span class="k">self</span><span class="py">.lat</span><span class="nf">.abs</span><span class="p">(),</span> <span class="n">lat_c</span><span class="p">,</span> <span class="k">self</span><span class="py">.lon</span><span class="nf">.abs</span><span class="p">(),</span> <span class="n">lon_c</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Color</span> <span class="p">{</span>
  <span class="n">red</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="n">green</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="n">blue</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">city</span> <span class="k">in</span> <span class="p">[</span>
      <span class="n">City</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="s">"Dublin"</span><span class="p">,</span> <span class="n">lat</span><span class="p">:</span> <span class="mf">53.347778</span><span class="p">,</span> <span class="n">lon</span><span class="p">:</span> <span class="o">-</span><span class="mf">6.259722</span> <span class="p">},</span>
      <span class="n">City</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="s">"Oslo"</span><span class="p">,</span> <span class="n">lat</span><span class="p">:</span> <span class="mf">59.95</span><span class="p">,</span> <span class="n">lon</span><span class="p">:</span> <span class="mf">10.75</span> <span class="p">},</span>
      <span class="n">City</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="s">"Vancouver"</span><span class="p">,</span> <span class="n">lat</span><span class="p">:</span> <span class="mf">49.25</span><span class="p">,</span> <span class="n">lon</span><span class="p">:</span> <span class="o">-</span><span class="mf">123.1</span> <span class="p">},</span>
  <span class="p">]</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="o">*</span><span class="n">city</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="n">color</span> <span class="k">in</span> <span class="p">[</span>
      <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">:</span> <span class="mi">128</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">255</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">90</span> <span class="p">},</span>
      <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">254</span> <span class="p">},</span>
      <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">0</span> <span class="p">},</span>
  <span class="p">]</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// Switch this to use {} once you've added an implementation</span>
      <span class="c1">// for fmt::Display.</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="o">*</span><span class="n">color</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>
<p>You can view a full list of formatting traits and their argument types in the <code class="language-plaintext highlighter-rouge">std::fmt</code> documentation.</p>

<h3 id="activity-3">Activity</h3>
<p>Add an implementation of the <code class="language-plaintext highlighter-rouge">fmt::Display</code> trait for the <code class="language-plaintext highlighter-rouge">Color</code> struct above so that the output displays as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RGB (128, 255, 90) 0x80FF5A
RGB (0, 3, 254) 0x0003FE
RGB (0, 0, 0) 0x000000
Two hints if you get stuck:
</code></pre></div></div>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">Formatter</span><span class="p">,</span> <span class="n">Display</span><span class="p">};</span>

<span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">Color</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"RGB ({}, {}, {}) 0x{:0&gt;2X}{:0&gt;2X}{:0&gt;2X}"</span><span class="p">,</span>
              <span class="k">self</span><span class="py">.red</span><span class="p">,</span> <span class="k">self</span><span class="py">.green</span><span class="p">,</span> <span class="k">self</span><span class="py">.blue</span><span class="p">,</span>
              <span class="k">self</span><span class="py">.red</span><span class="p">,</span> <span class="k">self</span><span class="py">.green</span><span class="p">,</span> <span class="k">self</span><span class="py">.blue</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Color</span> <span class="p">{</span>
  <span class="n">red</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="n">green</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="n">blue</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">color</span> <span class="k">in</span> <span class="p">[</span>
      <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">:</span> <span class="mi">128</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">255</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">90</span> <span class="p">},</span>
      <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">254</span> <span class="p">},</span>
      <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">0</span> <span class="p">},</span>
  <span class="p">]</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// Switch this to use {} once you've added an implementation</span>
      <span class="c1">// for fmt::Display.</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="o">*</span><span class="n">color</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>You <a href="https://doc.rust-lang.org/std/fmt/#named-parameters">may need to list each color more than once</a>,
You can <a href="https://doc.rust-lang.org/std/fmt/#width">pad with zeros to a width of 2</a> with :0&gt;2.</p>

<p>See also:
<a href="https://doc.rust-lang.org/std/fmt/">std::fmt</a></p>]]></content><author><name>JJungs-lee</name></author><category term="RUST by Example" /><category term="Rust" /><category term="Example" /><summary type="html"><![CDATA[This is the source code of the traditional Hello World program.]]></summary></entry><entry><title type="html">Dev Setting - Settings Sync</title><link href="https://jjungs-lee.github.io//vs%20code/VSCODE-Dev-set(Settings-Sync)/" rel="alternate" type="text/html" title="Dev Setting - Settings Sync" /><published>2021-12-01T00:00:00+00:00</published><updated>2021-12-01T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//vs%20code/VSCODE%20-%20Dev%20set(Settings%20Sync)</id><content type="html" xml:base="https://jjungs-lee.github.io//vs%20code/VSCODE-Dev-set(Settings-Sync)/"><![CDATA[<p>I have a trouble cuz the development settings at home and at work are different.
It’s so inconvenient. So I’m trying to use syncing up settings(vscode plugin) on multiple devices.</p>

<h2 id="how-synchronize-configurations-to-multiple-devices">How synchronize configurations to multiple devices?</h2>
<h3 id="1-install-settings-sync-plugin">1. install Settings Sync plugin</h3>
<p><img src="/assets/images/vscode/settings_sync_1.png" alt="Figure 1" /></p>

<h3 id="2-create-a-github-token">2. Create a github token</h3>
<ul>
  <li>2-1. Login Github / go to <code class="language-plaintext highlighter-rouge">Settings &gt; Developeer settings &gt; Personal access tokens</code></li>
  <li>2-2. Click <code class="language-plaintext highlighter-rouge">Generate new token</code> <br />
<img src="/assets/images/vscode/settings_sync_2.png" alt="Figure 2" /></li>
  <li>2-3. Select <code class="language-plaintext highlighter-rouge">expiration</code> then <code class="language-plaintext highlighter-rouge">click to gist</code></li>
  <li>2-4. Copy token number</li>
</ul>

<h3 id="3-create-github-gist-id">3. Create Github Gist id</h3>
<ul>
  <li>3-1. Go to Gist page(<a href="https://gist.github.com" target="_blank">https://gist.github.com</a>) and login.</li>
  <li>3-2. Create as below &amp; click <code class="language-plaintext highlighter-rouge">Create secret gist</code>
<img src="/assets/images/vscode/settings_sync_3.png" alt="Figure 3" /></li>
  <li>3-3. Copy gist id (included URL)
    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example
https://gist.github.com/<span class="o">{</span>your github <span class="nb">id</span><span class="o">}</span>/<span class="o">{</span>your gist <span class="nb">id</span><span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="4-update-settingsjson-in-vscode">4. Update settings.json in VScode</h3>
<p>Write down the Gist id from step 3.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">   </span><span class="nl">"sync.gist"</span><span class="p">:</span><span class="w"> </span><span class="s2">"your gist id"</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.autoDownload"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.autoUpload"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.forceDownload"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.forceUpload"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.quietSync"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.removeExtensions"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.syncExtensions"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></code></pre></div></div>

<h3 id="5-update-synclocalsettingsjson-in-vscode">5. Update syncLocalSettings.json in VScode</h3>
<p>Write down the Github token id from step 2.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"ignoreUploadFiles"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"state.*"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"syncLocalSettings.json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">".DS_Store"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"sync.lock"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"projects.json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"projects_cache_vscode.json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"projects_cache_git.json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"projects_cache_svn.json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"gpm_projects.json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"gpm-recentItems.json"</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"ignoreUploadFolders"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"workspaceStorage"</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"ignoreExtensions"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
    </span><span class="nl">"gistDescription"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Visual Studio Code Settings Sync Gist"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="mi">343</span><span class="p">,</span><span class="w">
    </span><span class="nl">"token"</span><span class="p">:</span><span class="w"> </span><span class="s2">"YOUR_GITHUB_TOKEN"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"downloadPublicGist"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="nl">"supportedFileExtensions"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"code-snippets"</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"openTokenLink"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"disableUpdateMessage"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="nl">"lastUpload"</span><span class="p">:</span><span class="w"> </span><span class="s2">"null"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"lastDownload"</span><span class="p">:</span><span class="w"> </span><span class="s2">"null"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"githubEnterpriseUrl"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w">
    </span><span class="nl">"askGistDescription"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="nl">"customFiles"</span><span class="p">:</span><span class="w"> </span><span class="p">{},</span><span class="w">
    </span><span class="nl">"hostName"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w">
    </span><span class="nl">"universalKeybindings"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="nl">"autoUploadDelay"</span><span class="p">:</span><span class="w"> </span><span class="mi">20</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="6-upload-your-setting-to-gist">6. Upload your setting to Gist</h3>
<p>Press <code class="language-plaintext highlighter-rouge">Shift + Alt + U</code> (macOS: <code class="language-plaintext highlighter-rouge">Shift + Option + U</code>)</p>

<h3 id="7-download-setting">7. Download Setting</h3>
<p>Press <code class="language-plaintext highlighter-rouge">Shift + Alt + D</code> (macOS: <code class="language-plaintext highlighter-rouge">Shift + Option + D</code>)</p>

<h3 id="notes">Notes.</h3>
<ol>
  <li>File path (settings.json / syncLocalSettings.json)
    <ul>
      <li>Windows : %APPDATA%\Code\User</li>
      <li>MAX : $HOME/Library/Application Support/Code/User</li>
    </ul>
  </li>
</ol>]]></content><author><name>JJungs-lee</name></author><category term="VS Code" /><category term="IDE" /><category term="Sync up" /><category term="settings Sync" /><category term="Plugin" /><summary type="html"><![CDATA[I have a trouble cuz the development settings at home and at work are different. It’s so inconvenient. So I’m trying to use syncing up settings(vscode plugin) on multiple devices.]]></summary></entry><entry><title type="html">Github Actions: Setting for CI server</title><link href="https://jjungs-lee.github.io//github%20pages/Github-actions/" rel="alternate" type="text/html" title="Github Actions: Setting for CI server" /><published>2021-06-18T00:00:00+00:00</published><updated>2021-06-18T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//github%20pages/Github%20actions</id><content type="html" xml:base="https://jjungs-lee.github.io//github%20pages/Github-actions/"><![CDATA[<p>In the past, When distributing the homepage was using CI called <strong>travis</strong>.</p>

<p>A few days ago, I modified the page and pushed it. 
But automatic distribution did not work, so i went to the travis homepage. 
There was a notice like the one below.
All the projects were read-only, nothing could be done.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Since June 15th, 2021, the building on travis-ci.org is ceased. 
Please use travis-ci.com from now on.
Travis CI - Test and Deploy Your Code with Confidence is in read-only mode. 
The historical data can be downloaded to external file storage.
</code></pre></div></div>
<p>As an announcement, I am trying to move the project to <code class="language-plaintext highlighter-rouge">travis.com</code>.
However, while setting it up, it didn’t work properly. 
So I decided to look for something else.</p>

<h2 id="github-action">Github Action</h2>
<h3 id="what-is-github-action">What is Github Action?</h3>
<p>Github Action is a tool that can automate software development <code class="language-plaintext highlighter-rouge">workflow</code> based on Github repository. 
Simply put, it is a <strong>CI/CD tool</strong> directly provided by Github.</p>

<p><code class="language-plaintext highlighter-rouge">Workflow</code> can directly create a desired workflow based on various events such as build, test, package, 
release, and deploy that occur in the Github repository.</p>

<p><code class="language-plaintext highlighter-rouge">Workflow</code> runs in Linux, macOS, and Windows environments hosted on Github called Runners. 
And you can run these Runners directly in the environment hosted by the user (self-hosted runner).</p>

<p><code class="language-plaintext highlighter-rouge">Workflows</code> shared by multiple people can be found in the Github marketplace, and you can create your own and share them.</p>

<p>⏳ <strong>How long can it be used?</strong><br />
Up to 20 workflows can be registered per repository. 
And it can be executed for up to 6 hours for each stage called Job that exists in the workflow, and is automatically stopped when it exceeds.</p>

<p>And according to the Github account plan, the number of jobs that can be executed simultaneously throughout the entire Git repository is determined.
If you call Github API within a job, you can do it up to 1,000 times per hour.</p>

<p>💵 <strong>How much is the usage fee?</strong><br />
Public storage is free, and private storage is billed after the free usage granted to the account.
Based on the full private storage of the Github free account, 500MB of storage and running time of up to 2,000 minutes are provided per month.</p>

<p>If you want more information, please visit below links.</p>
<ul>
  <li><a href="https://github.com/features/actions">https://github.com/features/actions</a></li>
  <li><a href="https://docs.github.com/en/actions">https://docs.github.com/en/actions</a></li>
</ul>

<p>The official guide provides several basic templates. When using travis CI to build and push deployment, using <code class="language-plaintext highlighter-rouge">Rakefile</code>.
And then jekyll theme, so I took the <code class="language-plaintext highlighter-rouge">Ruby</code> template and tried to change it little by little.</p>

<p>At first, I just looked at it as it is in <code class="language-plaintext highlighter-rouge">.travis.yml</code>, but the github page repo push didn’t work perfectly.
I think token seems to be the problem.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nothing to commit, working tree clean
remote: Permission to 
jjungs-lee/jjungs-lee.github.io.git denied to github-actions[bot].
fatal: unable to access 'https://github.com/jjungs-lee/jjungs-lee.github.io.git/'
: The requested URL returned error: 403
rake aborted!
</code></pre></div></div>
<p>I tried creating a new token, and setting the environment.
However, the permission denial continued, and it took about 2 days to trouble shooting.</p>

<p>After searching, I finally found the answer from the link below.
<a href="https://github.community/t/automating-push-to-public-repo/17742">Automating push to public repo</a><br />
There were various things such as setting <code class="language-plaintext highlighter-rouge">http</code> or something else. 
but i set the token and various in <code class="language-plaintext highlighter-rouge">actions/checkout@v2</code> and followed the example.
<a href="https://github.com/actions/checkout#checkout-multiple-repos-nested">Checkout multiple repos (nested)</a></p>

<p>After that, I checked that it was working properly and updated the CI server with it.</p>

<p>It was a long and hard task, but i’m glad i was able to learn something new. haha 😊</p>]]></content><author><name>JJungs-lee</name></author><category term="Github Pages" /><category term="CI" /><category term="Github Actions" /><category term="Automation" /><category term="Travis" /><summary type="html"><![CDATA[In the past, When distributing the homepage was using CI called travis.]]></summary></entry><entry><title type="html">Github Pages: Testing for local server</title><link href="https://jjungs-lee.github.io//github/Testing-for-local-server" rel="alternate" type="text/html" title="Github Pages: Testing for local server" /><published>2021-05-05T00:00:00+00:00</published><updated>2021-05-05T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//github/Testing%20for%20local%20server</id><content type="html" xml:base="https://jjungs-lee.github.io//github/Testing-for-local-server"><![CDATA[<p>Before committing to github pages, you can upload your homepage locally through <strong>ruby</strong> and <strong>jekyll serve</strong>!</p>

<h2 id="installing-ruby--devkit--jekyll">Installing Ruby + Devkit &amp; Jekyll</h2>
<p>After downloading <a href="https://rubyinstaller.org/downloads/">Ruby</a>, open the ruby prompt and enter <code class="language-plaintext highlighter-rouge">gem install jekyll bundler</code> to proceed with the installation.<br />
After completing the installation, check if the installation was successful with <code class="language-plaintext highlighter-rouge">jekyll -v</code>.</p>

<h2 id="trobleshooting">TrobleShooting</h2>

<h3 id="1-using-bundle-exec-jekyll-serve-instead-of-jekyll-serve">1) Using <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve</code> instead of <code class="language-plaintext highlighter-rouge">jekyll serve</code></h3>
<p>When I try to run <code class="language-plaintext highlighter-rouge">jekyll serve</code> command, sometimes I keep getting bundle errors. 
In this case, it can be easily solved by using the <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve</code> command. 
It tells you what to do, so just follow the instructions in the <code class="language-plaintext highlighter-rouge">Ruby prompt</code>.</p>

<p>A message prompting you to bundle install or bundle update appears saying that bundle is not installed, so you can install it as it is.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D:\jjungs-page&gt;jekyll serve
Traceback (most recent call last):
 10: from C:/Ruby26-x64/bin/jekyll:23:in `&lt;main&gt;'
  9: from C:/Ruby26-x64/bin/jekyll:23:in `load'
  8: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/jekyll-4.0.0/exe/jekyll:11:in `&lt;top (required)&gt;'
  7: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/jekyll-4.0.0/lib/jekyll/plugin_manager.rb:52:in `require_from_bundler'
  6: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler.rb:149:in `setup'
  5: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler/runtime.rb:26:in `setup'
  4: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler/runtime.rb:26:in `map'
  3: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler/spec_set.rb:147:in `each'
  2: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler/spec_set.rb:147:in `each'
  1: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler/runtime.rb:31:in `block in setup'
C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler/runtime.rb:312:in `check_for_activated_spec!': You have already activated i18n 1.7.0, 
but your Gemfile requires i18n 0.9.5. Prepending `bundle exec` to your command may solve this. (Gem::LoadError)
</code></pre></div></div>

<h3 id="2-change-gemfile-and-_configyml-files">2) Change <code class="language-plaintext highlighter-rouge">Gemfile</code> and <code class="language-plaintext highlighter-rouge">_config.yml</code> files</h3>
<p>If you get a message that your gemfile is a problem, updating Gemfile
To solve the problem, you can do one of the two below.</p>

<ul>
  <li>Comment out the gem to remove(using #)</li>
  <li>Add <code class="language-plaintext highlighter-rouge">Gem</code> to the <code class="language-plaintext highlighter-rouge">Gemfile</code>, and add it to the <code class="language-plaintext highlighter-rouge">plugins:</code> part of the<code class="language-plaintext highlighter-rouge"> _config.yml</code> file.</li>
</ul>

<h3 id="3-run-chcp-65001-cmd">3) run <code class="language-plaintext highlighter-rouge">chcp 65001</code> cmd</h3>
<p>If you get an <code class="language-plaintext highlighter-rouge">Invalid CP949 character "\xE2"</code> error message, this may be an encoding problem on <strong>Windows</strong>.</p>

<blockquote>
  <p>If you use UTF-8 encoding, Jekyll will break if a file starts with characters representing a BOM. 
Therefore, remove this sequence of bytes if it appears at the beginning of your file.<br />
refer : <a href="https://jekyllrb.com/docs/installation/windows/">jekyll page</a></p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D:\jjungs-page&gt;bundle exec jekyll serve
Configuration file: D:/jjungs-page/_config.yml
            Source: D:/jjungs-page
       Destination: ./publishing
 Incremental build: disabled. Enable with --incremental
      Generating...
         AutoPages: Disabled/Not configured in site.config.
        Pagination: Complete, processed 2 pagination page(s)
       Jekyll Feed: Generating feed for posts
  Conversion error: Jekyll::Converters::Scss encountered an error while converting 'assets/css/main.scss':
                    Invalid CP949 character "\xE2" on line 54
jekyll 3.8.6 | Error:  Invalid CP949 character "\xE2" on line 54
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D:\jjungs-page&gt;chcp 65001
Active code page: 65001

D:\jjungs-page&gt;bundle exec jekyll serve
</code></pre></div></div>

<h2 id="finish">Finish</h2>
<p>Go to local page(http://127.0.0.1:4000/) and testing local test. Then Update and pushing it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D:\jjungs-page&gt;bundle exec jekyll serve
Configuration file: D:/jjungs-page/_config.yml
            Source: D:/jjungs-page
       Destination: ./publishing
 Incremental build: disabled. Enable with --incremental
      Generating...
         AutoPages: Disabled/Not configured in site.config.
        Pagination: Complete, processed 2 pagination page(s)
       Jekyll Feed: Generating feed for posts
                    done in 6.677 seconds.
 Auto-regeneration: enabled for 'D:/jjungs-page'
    Server address: http://127.0.0.1:4000
  Server running... press ctrl-c to stop.
      Regenerating: 1 file(s) changed at 2021-05-05 22:2
</code></pre></div></div>]]></content><author><name>JJungs-lee</name></author><category term="Github Pages" /><category term="Github Pages" /><category term="minimal-mistakes theme" /><summary type="html"><![CDATA[Before committing to github pages, you can upload your homepage locally through ruby and jekyll serve!]]></summary></entry><entry><title type="html">Algorithm - SORT</title><link href="https://jjungs-lee.github.io//Algorithm/algorithm-Sort" rel="alternate" type="text/html" title="Algorithm - SORT" /><published>2021-02-28T00:00:00+00:00</published><updated>2021-02-28T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//Algorithm/%5Balgorithm%5D%20Sort</id><content type="html" xml:base="https://jjungs-lee.github.io//Algorithm/algorithm-Sort"><![CDATA[<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cp">#define ARR_SIZE sizeof(arr) / sizeof(int)
#define SWAP(a, b) { int temp = a; a = b; b = temp; }
</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">quickSort</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Quick Sort</span>
  <span class="n">quickSort</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ARR_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Merge Sort</span>
  <span class="n">mergeSort</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ARR_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">quickSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span>
        <span class="n">l</span><span class="o">++</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">left</span><span class="p">)</span>
        <span class="n">r</span><span class="o">--</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SWAP</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">SWAP</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">pivot</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>

    <span class="n">quickSort</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">quickSort</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">temp</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">temp</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">temp</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">temp</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">l</span><span class="o">++</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">delete</span><span class="p">[]</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">mergeSort</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="n">mergeSort</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
    <span class="n">merge</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>JJungs-lee</name></author><category term="Algorithm" /><category term="Sort" /><category term="Quick Sort" /><category term="Merge Sort" /><summary type="html"><![CDATA[```cpp #include]]></summary></entry><entry><title type="html">Data Structure - HEAP</title><link href="https://jjungs-lee.github.io//Algorithm/Data-structure-Heap" rel="alternate" type="text/html" title="Data Structure - HEAP" /><published>2021-02-27T00:00:00+00:00</published><updated>2021-02-27T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//Algorithm/%5BData%20structure%5D%20Heap</id><content type="html" xml:base="https://jjungs-lee.github.io//Algorithm/Data-structure-Heap"><![CDATA[<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cp">#define SWAP(a, b) { int temp = a; a = b; b = temp; }
</span>
<span class="k">struct</span> <span class="nc">heap</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">tree</span><span class="p">[</span><span class="mi">40001</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">idx</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">top</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// Push &amp; Pop</span>
  <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tree</span><span class="p">[</span><span class="o">++</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">idx</span><span class="o">--</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="p">;)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">idx</span> <span class="o">||</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Sort</span>
  <span class="kt">void</span> <span class="n">heapify</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">largest</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">largest</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">largest</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">largest</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SWAP</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="n">largest</span><span class="p">]);</span>
      <span class="n">heapify</span><span class="p">(</span><span class="n">largest</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">buildHeap</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">heapify</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">heapSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">buildHeap</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SWAP</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
      <span class="n">heapify</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">heap</span> <span class="n">h</span><span class="p">;</span>

  <span class="n">h</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
  <span class="n">h</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="n">h</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">59</span><span class="p">);</span>
  <span class="n">h</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
  <span class="n">h</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
  <span class="n">h</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">h</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>

  <span class="n">h</span><span class="p">.</span><span class="n">heapSort</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">h</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>

  <span class="n">h</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="n">h</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="n">h</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="n">h</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>JJungs-lee</name></author><category term="Algorithm" /><category term="Heap" /><category term="Priority Queue" /><category term="Max heap" /><category term="Min heap" /><summary type="html"><![CDATA[```cpp #include]]></summary></entry><entry><title type="html">Data Structure - LIST</title><link href="https://jjungs-lee.github.io//Algorithm/Data-structure-List" rel="alternate" type="text/html" title="Data Structure - LIST" /><published>2021-02-24T00:00:00+00:00</published><updated>2021-02-24T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//Algorithm/%5BData%20structure%5D%20List</id><content type="html" xml:base="https://jjungs-lee.github.io//Algorithm/Data-structure-List"><![CDATA[<ul>
  <li>Also known as linked list</li>
  <li>The linked list is a data space in which data can be added and deleted whenever necessary, without a space of a fixed size.</li>
  <li>Linked list is a data structure that connects data that exist in a remote place with pointer.</li>
</ul>

<h2 id="basic-term">Basic term</h2>
<ul>
  <li>Node - Consists of data storage units (data values, pointers)</li>
  <li>Pointer - In each node, a space containing connection information (address) with the next or previous node, null value if there is no next node</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// Single linked list</span>
<span class="k">struct</span> <span class="nc">SNode</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">SNode</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">SNode</span><span class="o">*</span> <span class="n">sList</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">addSList</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SNode</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SNode</span><span class="p">;</span>
  <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">sList</span><span class="p">;</span>
  <span class="n">sList</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">printSList</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">SNode</span><span class="o">*</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">sList</span><span class="p">;</span> <span class="n">iter</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>

  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Double linked list</span>
<span class="k">struct</span> <span class="nc">DNode</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">DNode</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
  <span class="n">DNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DNode</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
<span class="n">DNode</span><span class="o">*</span> <span class="n">tail</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">addDList</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DNode</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DNode</span><span class="p">();</span>
  <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
  <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

  <span class="n">tail</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
  <span class="n">tail</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">deletaDList</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">DNode</span><span class="o">*</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">tail</span><span class="p">;</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">iter</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
      <span class="k">delete</span> <span class="n">iter</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">printDList</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">DNode</span><span class="o">*</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">tail</span><span class="p">;</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// SLL</span>
  <span class="n">sList</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="n">addSList</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="n">addSList</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
  <span class="n">printSList</span><span class="p">();</span>

  <span class="c1">// DLL</span>
  <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DNode</span><span class="p">();</span>
  <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DNode</span><span class="p">();</span>
  <span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
  <span class="n">tail</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
  <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

  <span class="n">addDList</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="n">addDList</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

  <span class="n">printDList</span><span class="p">();</span>
  <span class="n">deletaDList</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="n">printDList</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>JJungs-lee</name></author><category term="Algorithm" /><category term="List" /><category term="Single linked list" /><category term="Double linked list" /><summary type="html"><![CDATA[Also known as linked list The linked list is a data space in which data can be added and deleted whenever necessary, without a space of a fixed size. Linked list is a data structure that connects data that exist in a remote place with pointer.]]></summary></entry><entry><title type="html">RUST : How to check overflow and underflow in integer types</title><link href="https://jjungs-lee.github.io//rust/How-to-check-overflow-and-underflow-in-integer-types" rel="alternate" type="text/html" title="RUST : How to check overflow and underflow in integer types" /><published>2021-01-10T00:00:00+00:00</published><updated>2021-01-10T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//rust/How%20to%20check%20overflow%20and%20underflow%20in%20integer%20types</id><content type="html" xml:base="https://jjungs-lee.github.io//rust/How-to-check-overflow-and-underflow-in-integer-types"><![CDATA[<h3 id="what-is-overflow-and-underflow">What is overflow and underflow?</h3>
<p>Overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of digits – either higher than the maximum or lower than the minimum representable value. 
Underflow is a condition in a computer program where the result of a calculation is a number of smaller absolute value than the computer can actually represent in memory on its central processing unit (CPU).</p>

<p>Simply put, overflow and underflow happen when we assign a value that is <strong>out of range</strong> of the declared data type of the variable.
If the (absolute) value is too big, we call it <code class="language-plaintext highlighter-rouge">overflow</code>, if the value is too small, we call it <code class="language-plaintext highlighter-rouge">underflow</code>.</p>

<p>Instead of an error in the program, it usually causes the result to be unexpected. 
Data overflows have been listed as the number 8 most <strong>dangerous</strong> software error in the most recent CWE 2019 list, mostly because they often lead to <code class="language-plaintext highlighter-rouge">buffer overflows</code>, which are currently the number 1 most dangerous software error according to that list.</p>

<p>Most integer overflow and underflow conditions lead to erroneous program behavior but don’t cause any vulnerabilities. There is no error, there is no warning, you simply get a wrong result of the operation. So, they are very hard to discover and prevent.</p>

<p>So let’s see how to prevent these things in Rust.</p>

<h3 id="preventing-integer-overflows">Preventing Integer Overflows</h3>
<p>Rust provides standard library integer types have <code class="language-plaintext highlighter-rouge">checked_*</code> methods for common operations, such as checked_add for addition, etc.</p>

<p>The API form of each function is variable as follows.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Checked integer addition. Computes self + rhs, </span>
<span class="c1">// returning None if overflow occurred.</span>
<span class="k">pub</span> <span class="k">const</span> <span class="k">fn</span> <span class="nf">checked_add</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>

<span class="c1">//Checked integer subtraction. Computes self - rhs, </span>
<span class="c1">// returning None if overflow occurred.</span>
<span class="k">pub</span> <span class="k">const</span> <span class="k">fn</span> <span class="nf">checked_sub</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>

<span class="c1">// Checked integer multiplication. Computes self * rhs, </span>
<span class="c1">// returning None if overflow occurred.</span>
<span class="k">pub</span> <span class="k">const</span> <span class="k">fn</span> <span class="nf">checked_mul</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>

<span class="c1">// Checked integer division. Computes self / rhs, </span>
<span class="c1">// returning None if rhs == 0.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">checked_div</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>Looking at API form, Each function returns as an <code class="language-plaintext highlighter-rouge">Option</code> type. When an overflow or underflow problem occurs, it returns None and the rest return Some(T).</p>

<p>So, it is good to implement programming whether to proceed with the operation by checking the return or to cause panic.</p>

<p>Below code is a simple example. Let’s make a bug-free program by referring to the following.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">u32</span><span class="p">::</span><span class="nf">max_value</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">match</span> <span class="n">x</span><span class="nf">.checked_add</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} + {} = {}"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"overflow!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// count checker</span>
<span class="k">let</span> <span class="n">x</span><span class="p">:</span><span class="nb">u64</span> <span class="o">=</span> <span class="nn">u64</span><span class="p">::</span><span class="nf">min_value</span><span class="p">();</span>
<span class="k">if</span> <span class="n">x</span><span class="nf">.checked_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"This operation's result is underflow"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<p>reference)</p>
<ul>
  <li><a href="https://doc.rust-lang.org/std/primitive.u32.html">RUST API document</a></li>
  <li><a href="https://stackoverflow.com/questions/52646755/checking-for-integer-overflow-in-rust">Stack overflow</a></li>
</ul>]]></content><author><name>JJungs-lee</name></author><category term="RUST" /><category term="overflow" /><category term="underflow" /><category term="Data types" /><category term="checked_add" /><category term="checked_sub" /><summary type="html"><![CDATA[What is overflow and underflow? Overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of digits – either higher than the maximum or lower than the minimum representable value. Underflow is a condition in a computer program where the result of a calculation is a number of smaller absolute value than the computer can actually represent in memory on its central processing unit (CPU).]]></summary></entry><entry><title type="html">RUST : 19. Advanced Features</title><link href="https://jjungs-lee.github.io//rust/19.Advanced-Features" rel="alternate" type="text/html" title="RUST : 19. Advanced Features" /><published>2020-12-27T00:00:00+00:00</published><updated>2020-12-27T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//rust/19.Advanced%20Features</id><content type="html" xml:base="https://jjungs-lee.github.io//rust/19.Advanced-Features"><![CDATA[<h2 id="advanced-features">Advanced Features</h2>
<p>By now, you’ve learned the most commonly used parts of the Rust programming language. 
Before we do one more project in Chapter 20, we’ll look at a few aspects of the language you might run into every once in a while. 
You can use this chapter as a reference for when you encounter any unknowns when using Rust. 
The features you’ll learn to use in this chapter are useful in very specific situations. 
Although you might not reach for them often, we want to make sure you have a grasp of all the features Rust has to offer.</p>

<p>In this chapter, we’ll cover:</p>

<ul>
  <li>Unsafe Rust: how to opt out of some of Rust’s guarantees and take responsibility for manually upholding those guarantees</li>
  <li>Advanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits</li>
  <li>Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types</li>
  <li>Advanced functions and closures: function pointers and returning closures</li>
  <li>Macros: ways to define code that defines more code at compile time
It’s a panoply of Rust features with something for everyone! Let’s dive in!</li>
</ul>

<h2 id="unsafe-rust">Unsafe Rust</h2>
<p>All the code we’ve discussed so far has had Rust’s memory safety guarantees enforced at compile time. 
However, Rust has a second language hidden inside it that doesn’t enforce these memory safety guarantees: it’s called <strong>unsafe Rust</strong> and works just like regular Rust, but gives us extra superpowers.</p>

<p>Unsafe Rust exists because, by nature, static analysis is conservative. 
When the compiler tries to determine whether or not code upholds the guarantees, it’s better for it to reject some valid programs rather than accept some invalid programs. 
Although the code might be okay, as far as Rust is able to tell, it’s not! In these cases, you can use unsafe code to tell the compiler, “Trust me, I know what I’m doing.” The downside is that you use it at your own risk: if you use unsafe code incorrectly, problems due to memory unsafety, such as null pointer dereferencing, can occur.</p>

<p>Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. 
If Rust didn’t let you do unsafe operations, you couldn’t do certain tasks. 
Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system. 
Working with low-level systems programming is one of the goals of the language. Let’s explore what we can do with unsafe Rust and how to do it.</p>

<h3 id="unsafe-superpowers">Unsafe Superpowers</h3>
<p>To switch to unsafe Rust, use the <code class="language-plaintext highlighter-rouge">unsafe</code> keyword and then start a new block that holds the unsafe code. You can take five actions in unsafe Rust, called <code class="language-plaintext highlighter-rouge">unsafe superpowers</code>, that you can’t in safe Rust. 
Those superpowers include the ability to:</p>

<ul>
  <li>Dereference a raw pointer</li>
  <li>Call an unsafe function or method</li>
  <li>Access or modify a mutable static variable</li>
  <li>Implement an unsafe trait</li>
  <li>Access fields of <code class="language-plaintext highlighter-rouge">union</code>s</li>
</ul>

<p>It’s important to understand that <code class="language-plaintext highlighter-rouge">unsafe</code> doesn’t turn off the borrow checker or disable any other of Rust’s safety checks: if you use a reference in unsafe code, it will still be checked. 
The <code class="language-plaintext highlighter-rouge">unsafe</code> keyword only gives you access to these five features that are then not checked by the compiler for memory safety. 
You’ll still get some degree of safety inside of an unsafe block.</p>

<p>In addition, <code class="language-plaintext highlighter-rouge">unsafe</code> does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you’ll ensure the code inside an <code class="language-plaintext highlighter-rouge">unsafe</code> block will access memory in a valid way.</p>

<p>People are fallible, and mistakes will happen, but by requiring these five unsafe operations to be inside blocks annotated with <code class="language-plaintext highlighter-rouge">unsafe</code> you’ll know that any errors related to memory safety must be within an <code class="language-plaintext highlighter-rouge">unsafe</code> block. 
Keep <code class="language-plaintext highlighter-rouge">unsafe</code> blocks small; you’ll be thankful later when you investigate memory bugs.</p>

<p>To isolate unsafe code as much as possible, it’s best to enclose unsafe code within a safe abstraction and provide a safe API, which we’ll discuss later in the chapter when we examine unsafe functions and methods. 
Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. 
Wrapping unsafe code in a safe abstraction prevents uses of <code class="language-plaintext highlighter-rouge">unsafe</code> from leaking out into all the places that you or your users might want to use the functionality implemented with <code class="language-plaintext highlighter-rouge">unsafe</code> code, because using a safe abstraction is safe.</p>

<p>Let’s look at each of the five unsafe superpowers in turn. We’ll also look at some abstractions that provide a safe interface to unsafe code.</p>

<h3 id="dereferencing-a-raw-pointer">Dereferencing a Raw Pointer</h3>
<p>In Chapter 4, in the “Dangling References” section, we mentioned that the compiler ensures references are always valid. 
Unsafe Rust has two new types called raw pointers that are similar to references. As with references, <code class="language-plaintext highlighter-rouge">raw pointers</code> can be immutable or mutable and are written as <code class="language-plaintext highlighter-rouge">*const T</code> and <code class="language-plaintext highlighter-rouge">*mut T</code>, respectively. 
The asterisk isn’t the dereference operator; it’s part of the type name. 
In the context of raw pointers, <code class="language-plaintext highlighter-rouge">immutable</code> means that the pointer can’t be directly assigned to after being dereferenced.</p>

<p>Different from references and smart pointers, raw pointers:</p>

<ul>
  <li>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</li>
  <li>Aren’t guaranteed to point to valid memory</li>
  <li>Are allowed to be null</li>
  <li>Don’t implement any automatic cleanup</li>
</ul>

<p>By opting out of having Rust enforce these guarantees, you can give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust’s guarantees don’t apply.</p>

<p>Listing 19-1 shows how to create an immutable and a mutable raw pointer from references.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="k">mut</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i32</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">num</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">;</span>
</code></pre></div></div>
<h4 id="listing-19-1-creating-raw-pointers-from-references">Listing 19-1: Creating raw pointers from references</h4>

<p>Notice that we don’t include the <code class="language-plaintext highlighter-rouge">unsafe</code> keyword in this code. 
We can create raw pointers in safe code; we just can’t dereference raw pointers outside an unsafe block, as you’ll see in a bit.</p>

<p>We’ve created raw pointers by using <code class="language-plaintext highlighter-rouge">as</code> to cast an immutable and a mutable reference into their corresponding raw pointer types. Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can’t make that assumption about just any raw pointer.</p>

<p>Next, we’ll create a raw pointer whose validity we can’t be so certain of. 
Listing 19-2 shows how to create a raw pointer to an arbitrary location in memory. 
Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might error with a segmentation fault. 
Usually, there is no good reason to write code like this, but it is possible.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">address</span> <span class="o">=</span> <span class="mi">0x012345usize</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">address</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i32</span><span class="p">;</span>
</code></pre></div></div>
<h4 id="listing-19-2-creating-a-raw-pointer-to-an-arbitrary-memory-address">Listing 19-2: Creating a raw pointer to an arbitrary memory address</h4>

<p>Recall that we can create raw pointers in safe code, but we can’t <em>dereference</em> raw pointers and read the data being pointed to. 
In Listing 19-3, we use the dereference operator <code class="language-plaintext highlighter-rouge">*</code> on a raw pointer that requires an <code class="language-plaintext highlighter-rouge">unsafe</code> block.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="k">mut</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i32</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">num</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">;</span>

    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"r1 is: {}"</span><span class="p">,</span> <span class="o">*</span><span class="n">r1</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"r2 is: {}"</span><span class="p">,</span> <span class="o">*</span><span class="n">r2</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-3-dereferencing-raw-pointers-within-an-unsafe-block">Listing 19-3: Dereferencing raw pointers within an unsafe block</h4>

<p>Creating a pointer does no harm; it’s only when we try to access the value that it points at that we might end up dealing with an invalid value.</p>

<p>Note also that in Listing 19-1 and 19-3, we created <code class="language-plaintext highlighter-rouge">*const i32</code> and <code class="language-plaintext highlighter-rouge">*mut i32</code> raw pointers that both pointed to the same memory location, where <code class="language-plaintext highlighter-rouge">num</code> is stored. 
If we instead tried to create an immutable and a mutable reference to <code class="language-plaintext highlighter-rouge">num</code>, the code would not have compiled because Rust’s ownership rules don’t allow a mutable reference at the same time as any immutable references. 
With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</p>

<p>With all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you’ll see in the next section, “Calling an Unsafe Function or Method.” 
Another case is when building up safe abstractions that the borrow checker doesn’t understand. 
We’ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.</p>

<h3 id="calling-an-unsafe-function-or-method">Calling an Unsafe Function or Method</h3>
<p>The second type of operation that requires an unsafe block is calls to unsafe functions. 
Unsafe functions and methods look exactly like regular functions and methods, but they have an extra <code class="language-plaintext highlighter-rouge">unsafe</code> before the rest of the definition. 
The <code class="language-plaintext highlighter-rouge">unsafe</code> keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can’t guarantee we’ve met these requirements. 
By calling an unsafe function within an <code class="language-plaintext highlighter-rouge">unsafe</code> block, we’re saying that we’ve read this function’s documentation and take responsibility for upholding the function’s contracts.</p>

<p>Here is an unsafe function named <code class="language-plaintext highlighter-rouge">dangerous</code> that doesn’t do anything in its body:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">dangerous</span><span class="p">()</span> <span class="p">{}</span>

    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nf">dangerous</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>We must call the <code class="language-plaintext highlighter-rouge">dangerous</code> function within a separate <code class="language-plaintext highlighter-rouge">unsafe</code> block. If we try to call <code class="language-plaintext highlighter-rouge">dangerous</code> without the <code class="language-plaintext highlighter-rouge">unsafe</code> block, we’ll get an error:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="k">unsafe</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/unsafe-example)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0133</span><span class="p">]:</span> <span class="n">call</span> <span class="n">to</span> <span class="k">unsafe</span> <span class="n">function</span> <span class="n">is</span> <span class="k">unsafe</span> <span class="n">and</span> <span class="n">requires</span> <span class="k">unsafe</span> <span class="n">function</span> <span class="n">or</span> <span class="n">block</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>     <span class="nf">dangerous</span><span class="p">();</span>
  <span class="p">|</span>     <span class="o">^^^^^^^^^^^</span> <span class="n">call</span> <span class="n">to</span> <span class="k">unsafe</span> <span class="n">function</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">consult</span> <span class="n">the</span> <span class="n">function</span><span class="nv">'s</span> <span class="n">documentation</span> <span class="k">for</span> <span class="n">information</span> <span class="n">on</span> <span class="n">how</span> <span class="n">to</span> <span class="n">avoid</span> <span class="n">undefined</span> <span class="n">behavior</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0133</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="k">unsafe</span><span class="o">-</span><span class="n">example</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>By inserting the <code class="language-plaintext highlighter-rouge">unsafe</code> block around our call to <code class="language-plaintext highlighter-rouge">dangerous</code>, we’re asserting to Rust that we’ve read the function’s documentation, we understand how to use it properly, and we’ve verified that we’re fulfilling the contract of the function.</p>

<p>Bodies of unsafe functions are effectively <code class="language-plaintext highlighter-rouge">unsafe</code> blocks, so to perform other unsafe operations within an unsafe function, we don’t need to add another <code class="language-plaintext highlighter-rouge">unsafe</code> block.</p>

<h3 id="creating-a-safe-abstraction-over-unsafe-code">Creating a Safe Abstraction over Unsafe Code</h3>
<p>Just because a function contains unsafe code doesn’t mean we need to mark the entire function as unsafe. 
In fact, wrapping unsafe code in a safe function is a common abstraction. 
As an example, let’s study a function from the standard library, <code class="language-plaintext highlighter-rouge">split_at_mut</code>, that requires some unsafe code and explore how we might implement it. 
This safe method is defined on mutable slices: it takes one slice and makes it two by splitting the slice at the index given as an argument. Listing 19-4 shows how to use <code class="language-plaintext highlighter-rouge">split_at_mut</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>

    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">v</span><span class="p">[</span><span class="o">..</span><span class="p">];</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">r</span><span class="nf">.split_at_mut</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]);</span>
</code></pre></div></div>
<h4 id="listing-19-4-using-the-safe-split_at_mut-function">Listing 19-4: Using the safe split_at_mut function</h4>

<p>We can’t implement this function using only safe Rust. An attempt might look something like Listing 19-5, which won’t compile. 
For simplicity, we’ll implement <code class="language-plaintext highlighter-rouge">split_at_mut</code> as a function rather than a method and only for slices of <code class="language-plaintext highlighter-rouge">i32</code> values rather than for a generic type T.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">split_at_mut</span><span class="p">(</span><span class="n">slice</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">],</span> <span class="n">mid</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.len</span><span class="p">();</span>

    <span class="nd">assert!</span><span class="p">(</span><span class="n">mid</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">);</span>

    <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">slice</span><span class="p">[</span><span class="o">..</span><span class="n">mid</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">slice</span><span class="p">[</span><span class="n">mid</span><span class="o">..</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-5-an-attempted-implementation-of-split_at_mut-using-only-safe-rust">Listing 19-5: An attempted implementation of split_at_mut using only safe Rust</h4>

<p>This function first gets the total length of the slice. 
Then it asserts that the index given as a parameter is within the slice by checking whether it’s less than or equal to the length. 
The assertion means that if we pass an index that is greater than the length to split the slice at, the function will panic before it attempts to use that index.</p>

<p>Then we return two mutable slices in a tuple: one from the start of the original slice to the <code class="language-plaintext highlighter-rouge">mid</code> index and another from <code class="language-plaintext highlighter-rouge">mid</code> to the end of the slice.</p>

<p>When we try to compile the code in Listing 19-5, we’ll get an error.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="k">unsafe</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/unsafe-example)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0499</span><span class="p">]:</span> <span class="n">cannot</span> <span class="n">borrow</span> <span class="err">`</span><span class="o">*</span><span class="n">slice</span><span class="err">`</span> <span class="k">as</span> <span class="n">mutable</span> <span class="n">more</span> <span class="n">than</span> <span class="n">once</span> <span class="n">at</span> <span class="n">a</span> <span class="n">time</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span><span class="mi">30</span>
  <span class="p">|</span>
<span class="mi">1</span> <span class="p">|</span> <span class="k">fn</span> <span class="nf">split_at_mut</span><span class="p">(</span><span class="n">slice</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">],</span> <span class="n">mid</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">])</span> <span class="p">{</span>
  <span class="p">|</span>                        <span class="o">-</span> <span class="k">let</span><span class="nv">'s</span> <span class="n">call</span> <span class="n">the</span> <span class="n">lifetime</span> <span class="n">of</span> <span class="n">this</span> <span class="n">reference</span> <span class="err">`'</span><span class="mi">1</span><span class="err">`</span>
<span class="o">...</span>
<span class="mi">6</span> <span class="p">|</span>     <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">slice</span><span class="p">[</span><span class="o">..</span><span class="n">mid</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">slice</span><span class="p">[</span><span class="n">mid</span><span class="o">..</span><span class="p">])</span>
  <span class="p">|</span>     <span class="o">-------------------------^^^^^--------</span>
  <span class="p">|</span>     <span class="p">|</span>     <span class="p">|</span>                  <span class="p">|</span>
  <span class="p">|</span>     <span class="p">|</span>     <span class="p">|</span>                  <span class="n">second</span> <span class="n">mutable</span> <span class="n">borrow</span> <span class="n">occurs</span> <span class="n">here</span>
  <span class="p">|</span>     <span class="p">|</span>     <span class="n">first</span> <span class="n">mutable</span> <span class="n">borrow</span> <span class="n">occurs</span> <span class="n">here</span>
  <span class="p">|</span>     <span class="n">returning</span> <span class="n">this</span> <span class="n">value</span> <span class="n">requires</span> <span class="n">that</span> <span class="err">`</span><span class="o">*</span><span class="n">slice</span><span class="err">`</span> <span class="n">is</span> <span class="n">borrowed</span> <span class="k">for</span> <span class="err">`'</span><span class="mi">1</span><span class="err">`</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0499</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="k">unsafe</span><span class="o">-</span><span class="n">example</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of the slice; it only knows that we’re borrowing from the same slice twice. 
Borrowing different parts of a slice is fundamentally okay because the two slices aren’t overlapping, but Rust isn’t smart enough to know this. 
When we know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>

<p>Listing 19-6 shows how to use an <code class="language-plaintext highlighter-rouge">unsafe</code> block, a raw pointer, and some calls to unsafe functions to make the implementation of <code class="language-plaintext highlighter-rouge">split_at_mut</code> work.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">slice</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">split_at_mut</span><span class="p">(</span><span class="n">slice</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">],</span> <span class="n">mid</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

    <span class="nd">assert!</span><span class="p">(</span><span class="n">mid</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">);</span>

    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="p">(</span>
            <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts_mut</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">mid</span><span class="p">),</span>
            <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts_mut</span><span class="p">(</span><span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">mid</span><span class="p">),</span> <span class="n">len</span> <span class="o">-</span> <span class="n">mid</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-6-using-unsafe-code-in-the-implementation-of-the-split_at_mut-function">Listing 19-6: Using unsafe code in the implementation of the split_at_mut function</h4>

<p>Recall from “The Slice Type” section in Chapter 4 that slices are a pointer to some data and the length of the slice. 
We use the <code class="language-plaintext highlighter-rouge">len</code> method to get the length of a slice and the <code class="language-plaintext highlighter-rouge">as_mut_ptr</code> method to access the raw pointer of a slice. 
In this case, because we have a mutable slice to <code class="language-plaintext highlighter-rouge">i32</code> values, <code class="language-plaintext highlighter-rouge">as_mut_ptr</code> returns a raw pointer with the type <code class="language-plaintext highlighter-rouge">*mut i32</code>, which we’ve stored in the variable <code class="language-plaintext highlighter-rouge">ptr</code>.</p>

<p>We keep the assertion that the <code class="language-plaintext highlighter-rouge">mid</code> index is within the slice. 
Then we get to the unsafe code: the <code class="language-plaintext highlighter-rouge">slice::from_raw_parts_mut</code> function takes a raw pointer and a length, and it creates a slice. 
We use this function to create a slice that starts from <code class="language-plaintext highlighter-rouge">ptr</code> and is <code class="language-plaintext highlighter-rouge">mid</code> items long. 
Then we call the <code class="language-plaintext highlighter-rouge">add</code> method on <code class="language-plaintext highlighter-rouge">ptr</code> with mid as an argument to get a raw pointer that starts at <code class="language-plaintext highlighter-rouge">mid</code>, and we create a slice using that pointer and the remaining number of items after mid as the length.</p>

<p>The function <code class="language-plaintext highlighter-rouge">slice::from_raw_parts_mut</code> is unsafe because it takes a raw pointer and must trust that this pointer is valid. 
The <code class="language-plaintext highlighter-rouge">add</code> method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. 
Therefore, we had to put an <code class="language-plaintext highlighter-rouge">unsafe</code> block around our calls to <code class="language-plaintext highlighter-rouge">slice::from_raw_parts_mut</code> and <code class="language-plaintext highlighter-rouge">add</code> so we could call them. 
By looking at the code and by adding the assertion that <code class="language-plaintext highlighter-rouge">mid</code> must be less than or equal to <code class="language-plaintext highlighter-rouge">len</code>, we can tell that all the raw pointers used within the <code class="language-plaintext highlighter-rouge">unsafe</code> block will be valid pointers to data within the slice. This is an acceptable and appropriate use of <code class="language-plaintext highlighter-rouge">unsafe</code>.</p>

<p>Note that we don’t need to mark the resulting <code class="language-plaintext highlighter-rouge">split_at_mut</code> function as <code class="language-plaintext highlighter-rouge">unsafe</code>, and we can call this function from safe Rust. 
We’ve created a safe abstraction to the unsafe code with an implementation of the function that uses <code class="language-plaintext highlighter-rouge">unsafe</code> code in a safe way, because it creates only valid pointers from the data this function has access to.</p>

<p>In contrast, the use of <code class="language-plaintext highlighter-rouge">slice::from_raw_parts_mut</code> in Listing 19-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">slice</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">address</span> <span class="o">=</span> <span class="mi">0x01234usize</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">address</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">slice</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts_mut</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span> <span class="p">};</span>
</code></pre></div></div>
<h4 id="listing-19-7-creating-a-slice-from-an-arbitrary-memory-location">Listing 19-7: Creating a slice from an arbitrary memory location</h4>

<p>We don’t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid <code class="language-plaintext highlighter-rouge">i32</code> values. 
Attempting to use <code class="language-plaintext highlighter-rouge">slice</code> as though it’s a valid slice results in undefined behavior.</p>

<h3 id="using-extern-functions-to-call-external-code">Using extern Functions to Call External Code</h3>
<p>Sometimes, your Rust code might need to interact with code written in another language. 
For this, Rust has a keyword, <code class="language-plaintext highlighter-rouge">extern</code>, that facilitates the creation and use of a <strong>Foreign Function Interface</strong> (FFI). 
An FFI is a way for a programming language to define functions and enable a different (foreign) programming language to call those functions.</p>

<p>Listing 19-8 demonstrates how to set up an integration with the <code class="language-plaintext highlighter-rouge">abs</code> function from the C standard library. 
Functions declared within <code class="language-plaintext highlighter-rouge">extern</code> blocks are always unsafe to call from Rust code. 
The reason is that other languages don’t enforce Rust’s rules and guarantees, and Rust can’t check them, so responsibility falls on the programmer to ensure safety.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">abs</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Absolute value of -3 according to C: {}"</span><span class="p">,</span> <span class="nf">abs</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-8-declaring-and-calling-an-extern-function-defined-in-another-language">Listing 19-8: Declaring and calling an extern function defined in another language</h4>

<p>Within the <code class="language-plaintext highlighter-rouge">extern "C"</code> block, we list the names and signatures of external functions from another language we want to call. 
The <code class="language-plaintext highlighter-rouge">"C"</code> part defines which <em>application binary interface</em> (ABI) the external function uses: the ABI defines how to call the function at the assembly level. 
The <code class="language-plaintext highlighter-rouge">"C"</code> ABI is the most common and follows the C programming language’s ABI.</p>

<blockquote>
  <p><strong>Calling Rust Functions from Other Languages</strong><br />
We can also use <code class="language-plaintext highlighter-rouge">extern</code> to create an interface that allows other languages to call Rust functions. 
Instead of an <code class="language-plaintext highlighter-rouge">extern</code> block, we add the <code class="language-plaintext highlighter-rouge">extern</code> keyword and specify the ABI to use just before the <code class="language-plaintext highlighter-rouge">fn</code> keyword. 
We also need to add a <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> annotation to tell the Rust compiler not to mangle the name of this function. 
<strong>Mangling</strong> is when a compiler changes the name we’ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. 
Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler’s name mangling.<br />
In the following example, we make the <code class="language-plaintext highlighter-rouge">call_from_c</code> function accessible from C code, after it’s compiled to a shared library and linked from C:</p>
  <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nd">#[no_mangle]</span>
   <span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">call_from_c</span><span class="p">()</span> <span class="p">{</span>
       <span class="nd">println!</span><span class="p">(</span><span class="s">"Just called a Rust function from C!"</span><span class="p">);</span>
   <span class="p">}</span>
</code></pre></div>  </div>
  <p>This usage of <code class="language-plaintext highlighter-rouge">extern</code> does not require <code class="language-plaintext highlighter-rouge">unsafe</code>.</p>
</blockquote>

<h3 id="accessing-or-modifying-a-mutable-static-variable">Accessing or Modifying a Mutable Static Variable</h3>
<p>Until now, we’ve not talked about <code class="language-plaintext highlighter-rouge">global variables</code>, which Rust does support but can be problematic with Rust’s ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.</p>

<p>In Rust, global variables are called <code class="language-plaintext highlighter-rouge">static</code> variables. 
Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">static</span> <span class="n">HELLO_WORLD</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"name is: {}"</span><span class="p">,</span> <span class="n">HELLO_WORLD</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-9-defining-and-using-an-immutable-static-variable">Listing 19-9: Defining and using an immutable static variable</h4>

<p>Static variables are similar to constants, which we discussed in the “Differences Between Variables and Constants” section in Chapter 3. 
The names of static variables are in <code class="language-plaintext highlighter-rouge">SCREAMING_SNAKE_CASE</code> by convention, and we must annotate the variable’s type, which is <code class="language-plaintext highlighter-rouge">&amp;'static str</code> in this example. 
Static variables can only store references with the <code class="language-plaintext highlighter-rouge">'static</code> lifetime, which means the Rust compiler can figure out the lifetime; we don’t need to annotate it explicitly. Accessing an immutable static variable is safe.</p>

<p>Constants and immutable static variables might seem similar, but a subtle difference is that values in a static variable have a fixed address in memory. 
Using the value will always access the same data. Constants, on the other hand, are allowed to duplicate their data whenever they’re used.</p>

<p>Another difference between constants and static variables is that static variables can be mutable. 
Accessing and modifying mutable static variables is <em>unsafe</em>. 
Listing 19-10 shows how to declare, access, and modify a mutable static variable named <code class="language-plaintext highlighter-rouge">COUNTER</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">static</span> <span class="k">mut</span> <span class="n">COUNTER</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">add_to_count</span><span class="p">(</span><span class="n">inc</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="n">COUNTER</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">add_to_count</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"COUNTER: {}"</span><span class="p">,</span> <span class="n">COUNTER</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-10-reading-from-or-writing-to-a-mutable-static-variable-is-unsafe">Listing 19-10: Reading from or writing to a mutable static variable is unsafe</h4>

<p>As with regular variables, we specify mutability using the <code class="language-plaintext highlighter-rouge">mut</code> keyword. 
Any code that reads or writes from <code class="language-plaintext highlighter-rouge">COUNTER</code> must be within an <code class="language-plaintext highlighter-rouge">unsafe</code> block. 
This code compiles and prints <code class="language-plaintext highlighter-rouge">COUNTER: 3</code> as we would expect because it’s single threaded. 
Having multiple threads access <code class="language-plaintext highlighter-rouge">COUNTER</code> would likely result in data races.</p>

<p>With mutable data that is globally accessible, it’s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. 
Where possible, it’s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.</p>

<h3 id="implementing-an-unsafe-trait">Implementing an Unsafe Trait</h3>
<p>The final action that works only with <code class="language-plaintext highlighter-rouge">unsafe</code> is implementing an unsafe trait. 
A trait is unsafe when at least one of its methods has some invariant that the compiler can’t verify. 
We can declare that a trait is <code class="language-plaintext highlighter-rouge">unsafe</code> by adding the <code class="language-plaintext highlighter-rouge">unsafe</code> keyword before <code class="language-plaintext highlighter-rouge">trait</code> and marking the implementation of the trait as <code class="language-plaintext highlighter-rouge">unsafe</code> too, as shown in Listing 19-11.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="c1">// methods go here</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="k">impl</span> <span class="n">Foo</span> <span class="k">for</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="c1">// method implementations go here</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>
<h4 id="listing-19-11-defining-and-implementing-an-unsafe-trait">Listing 19-11: Defining and implementing an unsafe trait</h4>

<p>By using <code class="language-plaintext highlighter-rouge">unsafe impl</code>, we’re promising that we’ll uphold the invariants that the compiler can’t verify.</p>

<p>As an example, recall the <code class="language-plaintext highlighter-rouge">Sync</code> and <code class="language-plaintext highlighter-rouge">Send</code> marker traits we discussed in the “Extensible Concurrency with the <code class="language-plaintext highlighter-rouge">Sync</code> and <code class="language-plaintext highlighter-rouge">Send</code> Traits” section in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of <code class="language-plaintext highlighter-rouge">Send</code> and <code class="language-plaintext highlighter-rouge">Sync</code> types. 
If we implement a type that contains a type that is not <code class="language-plaintext highlighter-rouge">Send</code> or <code class="language-plaintext highlighter-rouge">Sync</code>, such as raw pointers, and we want to mark that type as <code class="language-plaintext highlighter-rouge">Send</code> or <code class="language-plaintext highlighter-rouge">Sync</code>, we must use <code class="language-plaintext highlighter-rouge">unsafe</code>. 
Rust can’t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with <code class="language-plaintext highlighter-rouge">unsafe</code>.</p>

<h3 id="accessing-fields-of-a-union">Accessing Fields of a Union</h3>
<p>A <code class="language-plaintext highlighter-rouge">union</code> is similar to a <code class="language-plaintext highlighter-rouge">struct</code>, but only one declared field is used in a particular instance at one time. 
Unions are primarily used to interface with unions in C code. 
Accessing union fields is unsafe because Rust can’t guarantee the type of the data currently being stored in the union instance. 
You can learn more about unions in <a href="https://doc.rust-lang.org/reference/items/unions.html">the reference</a>.</p>

<h3 id="when-to-use-unsafe-code">When to Use Unsafe Code</h3>
<p>Using <code class="language-plaintext highlighter-rouge">unsafe</code> to take one of the five actions (superpowers) just discussed isn’t wrong or even frowned upon. 
But it is trickier to get <code class="language-plaintext highlighter-rouge">unsafe</code> code correct because the compiler can’t help uphold memory safety. 
When you have a reason to use <code class="language-plaintext highlighter-rouge">unsafe</code> code, you can do so, and having the explicit <code class="language-plaintext highlighter-rouge">unsafe</code> annotation makes it easier to track down the source of problems when they occur.</p>

<h2 id="advanced-traits">Advanced Traits</h2>
<p>We first covered traits in the “Traits: Defining Shared Behavior” section of Chapter 10, but as with lifetimes, we didn’t discuss the more advanced details. 
Now that you know more about Rust, we can get into the nitty-gritty.</p>

<h3 id="specifying-placeholder-types-in-trait-definitions-with-associated-types">Specifying Placeholder Types in Trait Definitions with Associated Types</h3>
<p><em>Associated types</em> connect a type placeholder with a trait such that the trait method definitions can use these placeholder types in their signatures. 
The implementor of a trait will specify the concrete type to be used in this type’s place for the particular implementation. 
That way, we can define a trait that uses some types without needing to know exactly what those types are until the trait is implemented.</p>

<p>We’ve described most of the advanced features in this chapter as being rarely needed. 
Associated types are somewhere in the middle: they’re used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.</p>

<p>One example of a trait with an associated type is the <code class="language-plaintext highlighter-rouge">Iterator</code> trait that the standard library provides. 
The associated type is named <code class="language-plaintext highlighter-rouge">Item</code> and stands in for the type of the values the type implementing the <code class="language-plaintext highlighter-rouge">Iterator</code> trait is iterating over. 
In “The <code class="language-plaintext highlighter-rouge">Iterator</code> Trait and the <code class="language-plaintext highlighter-rouge">next</code> Method” section of Chapter 13, we mentioned that the definition of the <code class="language-plaintext highlighter-rouge">Iterator</code> trait is as shown in Listing 19-12.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Iterator</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-12-the-definition-of-the-iterator-trait-that-has-an-associated-type-item">Listing 19-12: The definition of the Iterator trait that has an associated type Item</h4>

<p>The type <code class="language-plaintext highlighter-rouge">Item</code> is a placeholder type, and the <code class="language-plaintext highlighter-rouge">next</code> method’s definition shows that it will return values of type <code class="language-plaintext highlighter-rouge">Option&lt;Self::Item&gt;</code>. 
Implementors of the <code class="language-plaintext highlighter-rouge">Iterator</code> trait will specify the concrete type for <code class="language-plaintext highlighter-rouge">Item</code>, and the <code class="language-plaintext highlighter-rouge">next</code> method will return an <code class="language-plaintext highlighter-rouge">Option</code> containing a value of that concrete type.</p>

<p>Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. 
So why use associated types?</p>

<p>Let’s examine the difference between the two concepts with an example from Chapter 13 that implements the <code class="language-plaintext highlighter-rouge">Iterator</code> trait on the <code class="language-plaintext highlighter-rouge">Counter</code> struct. 
In Listing 13-21, we specified that the <code class="language-plaintext highlighter-rouge">Item</code> type was <code class="language-plaintext highlighter-rouge">u32</code>:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="n">Counter</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="nb">u32</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// --snip--</span>
</code></pre></div></div>

<p>This syntax seems comparable to that of generics. So why not just define the <code class="language-plaintext highlighter-rouge">Iterator</code> trait with generics, as shown in Listing 19-13?</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-13-a-hypothetical-definition-of-the-iterator-trait-using-generics">Listing 19-13: A hypothetical definition of the Iterator trait using generics</h4>

<p>The difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement <code class="language-plaintext highlighter-rouge">Iterator&lt;String&gt; for Counter</code> or any other type, we could have multiple implementations of <code class="language-plaintext highlighter-rouge">Iterator</code> for <code class="language-plaintext highlighter-rouge">Counter</code>. 
In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the <code class="language-plaintext highlighter-rouge">next</code> method on <code class="language-plaintext highlighter-rouge">Counter</code>, we would have to provide type annotations to indicate which implementation of <code class="language-plaintext highlighter-rouge">Iterator</code> we want to use.</p>

<p>With associated types, we don’t need to annotate types because we can’t implement a trait on a type multiple times. 
In Listing 19-12 with the definition that uses associated types, we can only choose what the type of <code class="language-plaintext highlighter-rouge">Item</code> will be once, because there can only be one <code class="language-plaintext highlighter-rouge">impl Iterator for Counter</code>. 
We don’t have to specify that we want an iterator of <code class="language-plaintext highlighter-rouge">u32</code> values everywhere that we call <code class="language-plaintext highlighter-rouge">next</code> on <code class="language-plaintext highlighter-rouge">Counter</code>.</p>

<h3 id="default-generic-type-parameters-and-operator-overloading">Default Generic Type Parameters and Operator Overloading</h3>
<p>When we use generic type parameters, we can specify a default concrete type for the generic type. 
This eliminates the need for implementors of the trait to specify a concrete type if the default type works. 
The syntax for specifying a default type for a generic type is <code class="language-plaintext highlighter-rouge">&lt;PlaceholderType=ConcreteType&gt;</code> when declaring the generic type.</p>

<p>A great example of a situation where this technique is useful is with operator overloading. 
<em>Operator overloading</em> is customizing the behavior of an operator (such as <code class="language-plaintext highlighter-rouge">+</code>) in particular situations.</p>

<p>Rust doesn’t allow you to create your own operators or overload arbitrary operators. 
But you can overload the operations and corresponding traits listed in <code class="language-plaintext highlighter-rouge">std::ops</code> by implementing the traits associated with the operator. 
For example, in Listing 19-14 we overload the <code class="language-plaintext highlighter-rouge">+</code> operator to add two <code class="language-plaintext highlighter-rouge">Point</code> instances together. 
We do this by implementing the <code class="language-plaintext highlighter-rouge">Add</code> trait on a <code class="language-plaintext highlighter-rouge">Point</code> struct:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nb">Add</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq)]</span>
<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Add</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Point</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Point</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="n">Point</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="n">other</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="n">other</span><span class="py">.y</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">assert_eq!</span><span class="p">(</span>
        <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span> <span class="o">+</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">3</span> <span class="p">},</span>
        <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">3</span> <span class="p">}</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-14-implementing-the-add-trait-to-overload-the--operator-for-point-instances">Listing 19-14: Implementing the Add trait to overload the + operator for Point instances</h4>

<p>The <code class="language-plaintext highlighter-rouge">add</code> method adds the <code class="language-plaintext highlighter-rouge">x</code> values of two <code class="language-plaintext highlighter-rouge">Point</code> instances and the <code class="language-plaintext highlighter-rouge">y</code> values of two <code class="language-plaintext highlighter-rouge">Point</code> instances to create a new <code class="language-plaintext highlighter-rouge">Point</code>. 
The <code class="language-plaintext highlighter-rouge">Add</code> trait has an associated type named <code class="language-plaintext highlighter-rouge">Output</code> that determines the type returned from the <code class="language-plaintext highlighter-rouge">add</code> method.</p>

<p>The default generic type in this code is within the <code class="language-plaintext highlighter-rouge">Add</code> trait. Here is its definition:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nb">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">=</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Rhs</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This code should look generally familiar: a trait with one method and an associated type. 
The new part is <code class="language-plaintext highlighter-rouge">Rhs=Self</code>: this syntax is c<em>alled default type parameters</em>. 
The <code class="language-plaintext highlighter-rouge">Rhs</code> generic type parameter (short for “right hand side”) defines the type of the <code class="language-plaintext highlighter-rouge">rhs</code> parameter in the <code class="language-plaintext highlighter-rouge">add</code> method. 
If we don’t specify a concrete type for <code class="language-plaintext highlighter-rouge">Rhs</code> when we implement the <code class="language-plaintext highlighter-rouge">Add</code> trait, the type of <code class="language-plaintext highlighter-rouge">Rhs</code> will default to <code class="language-plaintext highlighter-rouge">Self</code>, which will be the type we’re implementing <code class="language-plaintext highlighter-rouge">Add</code> on.</p>

<p>When we implemented <code class="language-plaintext highlighter-rouge">Add</code> for <code class="language-plaintext highlighter-rouge">Point</code>, we used the default for <code class="language-plaintext highlighter-rouge">Rhs</code> because we wanted to add two <code class="language-plaintext highlighter-rouge">Point</code> instances. 
Let’s look at an example of implementing the <code class="language-plaintext highlighter-rouge">Add</code> trait where we want to customize the <code class="language-plaintext highlighter-rouge">Rhs</code> type rather than using the default.</p>

<p>We have two structs, <code class="language-plaintext highlighter-rouge">Millimeters</code> and <code class="language-plaintext highlighter-rouge">Meters</code>, holding values in different units. 
We want to add values in millimeters to values in meters and have the implementation of <code class="language-plaintext highlighter-rouge">Add</code> do the conversion correctly. 
We can implement <code class="language-plaintext highlighter-rouge">Add</code> for <code class="language-plaintext highlighter-rouge">Millimeters</code> with <code class="language-plaintext highlighter-rouge">Meters</code> as the <code class="language-plaintext highlighter-rouge">Rhs</code>, as shown in Listing 19-15.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nb">Add</span><span class="p">;</span>

<span class="k">struct</span> <span class="nf">Millimeters</span><span class="p">(</span><span class="nb">u32</span><span class="p">);</span>
<span class="k">struct</span> <span class="nf">Meters</span><span class="p">(</span><span class="nb">u32</span><span class="p">);</span>

<span class="k">impl</span> <span class="nb">Add</span><span class="o">&lt;</span><span class="n">Meters</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Millimeters</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Millimeters</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Meters</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Millimeters</span> <span class="p">{</span>
        <span class="nf">Millimeters</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">other</span><span class="na">.0</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-15-implementing-the-add-trait-on-millimeters-to-add-millimeters-to-meters">Listing 19-15: Implementing the Add trait on Millimeters to add Millimeters to Meters</h4>

<p>To add <code class="language-plaintext highlighter-rouge">Millimeters</code> and <code class="language-plaintext highlighter-rouge">Meters</code>, we specify <code class="language-plaintext highlighter-rouge">impl Add&lt;Meters&gt;</code> to set the value of the <code class="language-plaintext highlighter-rouge">Rhs</code> type parameter instead of using the default of <code class="language-plaintext highlighter-rouge">Self</code>.</p>

<p>You’ll use default type parameters in two main ways:</p>

<ul>
  <li>To extend a type without breaking existing code</li>
  <li>To allow customization in specific cases most users won’t need</li>
</ul>

<p>The standard library’s <code class="language-plaintext highlighter-rouge">Add</code> trait is an example of the second purpose: usually, you’ll add two like types, but the <code class="language-plaintext highlighter-rouge">Add</code> trait provides the ability to customize beyond that. 
Using a default type parameter in the <code class="language-plaintext highlighter-rouge">Add</code> trait definition means you don’t have to specify the extra parameter most of the time. In other words, a bit of implementation boilerplate isn’t needed, making it easier to use the trait.</p>

<p>The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</p>

<h3 id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</h3>
<p>Nothing in Rust prevents a trait from having a method with the same name as another trait’s method, nor does Rust prevent you from implementing both traits on one type. It’s also possible to implement a method directly on the type with the same name as methods from traits.</p>

<p>When calling methods with the same name, you’ll need to tell Rust which one you want to use. 
Consider the code in Listing 19-16 where we’ve defined two traits, <code class="language-plaintext highlighter-rouge">Pilot</code> and <code class="language-plaintext highlighter-rouge">Wizard</code>, that both have a method called <code class="language-plaintext highlighter-rouge">fly</code>. 
We then implement both traits on a type <code class="language-plaintext highlighter-rouge">Human</code> that already has a method named <code class="language-plaintext highlighter-rouge">fly</code> implemented on it. 
Each <code class="language-plaintext highlighter-rouge">fly</code> method does something different.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">trait</span> <span class="n">Pilot</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Wizard</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Human</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Pilot</span> <span class="k">for</span> <span class="n">Human</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"This is your captain speaking."</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Wizard</span> <span class="k">for</span> <span class="n">Human</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Up!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Human</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"*waving arms furiously*"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-16-two-traits-are-defined-to-have-a-fly-method-and-are-implemented-on-the-human-type-and-a-fly-method-is-implemented-on-human-directly">Listing 19-16: Two traits are defined to have a fly method and are implemented on the Human type, and a fly method is implemented on Human directly</h4>

<p>When we call <code class="language-plaintext highlighter-rouge">fly</code> on an instance of <code class="language-plaintext highlighter-rouge">Human</code>, the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 19-17.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">person</span> <span class="o">=</span> <span class="n">Human</span><span class="p">;</span>
    <span class="n">person</span><span class="nf">.fly</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-17-calling-fly-on-an-instance-of-human">Listing 19-17: Calling fly on an instance of Human</h4>

<p>Running this code will print <code class="language-plaintext highlighter-rouge">*waving arms furiously*</code>, showing that Rust called the <code class="language-plaintext highlighter-rouge">fly</code> method implemented on <code class="language-plaintext highlighter-rouge">Human</code> directly.</p>

<p>To call the <code class="language-plaintext highlighter-rouge">fly</code> methods from either the <code class="language-plaintext highlighter-rouge">Pilot</code> trait or the <code class="language-plaintext highlighter-rouge">Wizard</code> trait, we need to use more explicit syntax to specify which <code class="language-plaintext highlighter-rouge">fly</code> method we mean. Listing 19-18 demonstrates this syntax.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">person</span> <span class="o">=</span> <span class="n">Human</span><span class="p">;</span>
    <span class="nn">Pilot</span><span class="p">::</span><span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">);</span>
    <span class="nn">Wizard</span><span class="p">::</span><span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">);</span>
    <span class="n">person</span><span class="nf">.fly</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-18-specifying-which-traits-fly-method-we-want-to-call">Listing 19-18: Specifying which trait’s fly method we want to call</h4>

<p>Specifying the trait name before the method name clarifies to Rust which implementation of <code class="language-plaintext highlighter-rouge">fly</code> we want to call. 
We could also write <code class="language-plaintext highlighter-rouge">Human::fly(&amp;person)</code>, which is equivalent to the <code class="language-plaintext highlighter-rouge">person.fly()</code> that we used in Listing 19-18, but this is a bit longer to write if we don’t need to disambiguate.</p>

<p>Running this code prints the following:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">traits</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/traits-example)</span>
    <span class="n">Finished</span> <span class="n">dev</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">in</span> <span class="mf">0.46</span><span class="n">s</span>
     <span class="n">Running</span> <span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">traits</span><span class="o">-</span><span class="n">example</span><span class="err">`</span>
<span class="n">This</span> <span class="n">is</span> <span class="n">your</span> <span class="n">captain</span> <span class="n">speaking</span><span class="py">.
Up</span><span class="o">!</span>
<span class="o">*</span><span class="n">waving</span> <span class="n">arms</span> <span class="n">furiously</span><span class="o">*</span>
</code></pre></div></div>
<p>Because the <code class="language-plaintext highlighter-rouge">fly</code> method takes a <code class="language-plaintext highlighter-rouge">self</code> parameter, if we had two <em>types</em> that both implement one trait, Rust could figure out which implementation of a trait to use based on the type of <code class="language-plaintext highlighter-rouge">self</code>.</p>

<p>However, associated functions that are part of traits don’t have a <code class="language-plaintext highlighter-rouge">self</code> parameter. 
When two types in the same scope implement that trait, Rust can’t figure out which type you mean unless you use <em>fully qualified syntax</em>. 
For example, the <code class="language-plaintext highlighter-rouge">Animal</code> trait in Listing 19-19 has the associated function <code class="language-plaintext highlighter-rouge">baby_name</code>, 
the implementation of <code class="language-plaintext highlighter-rouge">Animal</code> for the struct <code class="language-plaintext highlighter-rouge">Dog</code>, and the associated function <code class="language-plaintext highlighter-rouge">baby_name</code> defined on <code class="language-plaintext highlighter-rouge">Dog</code> directly.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">trait</span> <span class="n">Animal</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Dog</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Spot"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Animal</span> <span class="k">for</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"puppy"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"A baby dog is called a {}"</span><span class="p">,</span> <span class="nn">Dog</span><span class="p">::</span><span class="nf">baby_name</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-19-a-trait-with-an-associated-function-and-a-type-with-an-associated-function-of-the-same-name-that-also-implements-the-trait">Listing 19-19: A trait with an associated function and a type with an associated function of the same name that also implements the trait</h4>

<p>This code is for an animal shelter that wants to name all puppies Spot, which is implemented in the <code class="language-plaintext highlighter-rouge">baby_name</code> associated function that is defined on <code class="language-plaintext highlighter-rouge">Dog</code>. 
The <code class="language-plaintext highlighter-rouge">Dog</code> type also implements the trait <code class="language-plaintext highlighter-rouge">Animal</code>, which describes characteristics that all animals have. 
Baby dogs are called puppies, and that is expressed in the implementation of the <code class="language-plaintext highlighter-rouge">Animal</code> trait on <code class="language-plaintext highlighter-rouge">Dog</code> in the <code class="language-plaintext highlighter-rouge">baby_name</code> function associated with the <code class="language-plaintext highlighter-rouge">Animal</code> trait.</p>

<p>In <code class="language-plaintext highlighter-rouge">main</code>, we call the <code class="language-plaintext highlighter-rouge">Dog::baby_name</code> function, which calls the associated function defined on <code class="language-plaintext highlighter-rouge">Dog</code> directly. 
This code prints the following:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">traits</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/traits-example)</span>
    <span class="n">Finished</span> <span class="n">dev</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">in</span> <span class="mf">0.54</span><span class="n">s</span>
     <span class="n">Running</span> <span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">traits</span><span class="o">-</span><span class="n">example</span><span class="err">`</span>
<span class="n">A</span> <span class="n">baby</span> <span class="n">dog</span> <span class="n">is</span> <span class="n">called</span> <span class="n">a</span> <span class="n">Spot</span>
</code></pre></div></div>
<p>This output isn’t what we wanted. 
We want to call the <code class="language-plaintext highlighter-rouge">baby_name</code> function that is part of the <code class="language-plaintext highlighter-rouge">Animal</code> trait that we implemented on <code class="language-plaintext highlighter-rouge">Dog</code> so the code prints <code class="language-plaintext highlighter-rouge">A baby dog is called a puppy</code>. 
The technique of specifying the trait name that we used in Listing 19-18 doesn’t help here; if we change <code class="language-plaintext highlighter-rouge">main</code> to the code in Listing 19-20, we’ll get a compilation error.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"A baby dog is called a {}"</span><span class="p">,</span> <span class="nn">Animal</span><span class="p">::</span><span class="nf">baby_name</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-20-attempting-to-call-the-baby_name-function-from-the-animal-trait-but-rust-doesnt-know-which-implementation-to-use">Listing 19-20: Attempting to call the baby_name function from the Animal trait, but Rust doesn’t know which implementation to use</h4>

<p>Because <code class="language-plaintext highlighter-rouge">Animal::baby_name</code> is an associated function rather than a method, and thus doesn’t have a <code class="language-plaintext highlighter-rouge">self</code> parameter, Rust can’t figure out which implementation of <code class="language-plaintext highlighter-rouge">Animal::baby_name</code> we want. 
We’ll get this compiler error:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">traits</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/traits-example)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0283</span><span class="p">]:</span> <span class="k">type</span> <span class="n">annotations</span> <span class="n">needed</span>
  <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mi">43</span>
   <span class="p">|</span>
<span class="mi">2</span>  <span class="p">|</span>     <span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
   <span class="p">|</span>     <span class="o">-------------------------</span> <span class="n">required</span> <span class="n">by</span> <span class="err">`</span><span class="nn">Animal</span><span class="p">::</span><span class="n">baby_name</span><span class="err">`</span>
<span class="o">...</span>
<span class="mi">20</span> <span class="p">|</span>     <span class="nd">println!</span><span class="p">(</span><span class="s">"A baby dog is called a {}"</span><span class="p">,</span> <span class="nn">Animal</span><span class="p">::</span><span class="nf">baby_name</span><span class="p">());</span>
   <span class="p">|</span>                                           <span class="o">^^^^^^^^^^^^^^^^^</span> <span class="n">cannot</span> <span class="n">infer</span> <span class="k">type</span>
   <span class="p">|</span>
   <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">resolve</span> <span class="err">`</span><span class="n">_</span><span class="p">:</span> <span class="n">Animal</span><span class="err">`</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0283</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">traits</span><span class="o">-</span><span class="n">example</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>To disambiguate and tell Rust that we want to use the implementation of <code class="language-plaintext highlighter-rouge">Animal</code> for <code class="language-plaintext highlighter-rouge">Dog</code>, we need to use fully qualified syntax. Listing 19-21 demonstrates how to use fully qualified syntax.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"A baby dog is called a {}"</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Dog</span> <span class="k">as</span> <span class="n">Animal</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">baby_name</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-21-using-fully-qualified-syntax-to-specify-that-we-want-to-call-the-baby_name-function-from-the-animal-trait-as-implemented-on-dog">Listing 19-21: Using fully qualified syntax to specify that we want to call the baby_name function from the Animal trait as implemented on Dog</h4>

<p>We’re providing Rust with a type annotation within the angle brackets, which indicates we want to call the <code class="language-plaintext highlighter-rouge">baby_name</code> method from the <code class="language-plaintext highlighter-rouge">Animal</code> trait as implemented on <code class="language-plaintext highlighter-rouge">Dog</code> by saying that we want to treat the <code class="language-plaintext highlighter-rouge">Dog</code> type as an Animal for this function call. 
This code will now print what we want:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">traits</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/traits-example)</span>
    <span class="n">Finished</span> <span class="n">dev</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">in</span> <span class="mf">0.48</span><span class="n">s</span>
     <span class="n">Running</span> <span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">traits</span><span class="o">-</span><span class="n">example</span><span class="err">`</span>
<span class="n">A</span> <span class="n">baby</span> <span class="n">dog</span> <span class="n">is</span> <span class="n">called</span> <span class="n">a</span> <span class="n">puppy</span>
</code></pre></div></div>
<p>In general, fully qualified syntax is defined as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre></div></div>

<p>For associated functions, there would not be a <code class="language-plaintext highlighter-rouge">receiver</code>: there would only be the list of other arguments. You could use fully qualified syntax everywhere that you call functions or methods. However, you’re allowed to omit any part of this syntax that Rust can figure out from other information in the program. You only need to use this more verbose syntax in cases where there are multiple implementations that use the same name and Rust needs help to identify which implementation you want to call.</p>

<h3 id="using-supertraits-to-require-one-traits-functionality-within-another-trait">Using Supertraits to Require One Trait’s Functionality Within Another Trait</h3>
<p>Sometimes, you might need one trait to use another trait’s functionality. 
In this case, you need to rely on the dependent trait also being implemented. 
The trait you rely on is a <em>supertrait</em> of the trait you’re implementing.</p>

<p>For example, let’s say we want to make an <code class="language-plaintext highlighter-rouge">OutlinePrint</code> trait with an <code class="language-plaintext highlighter-rouge">outline_print</code> method that will print a value framed in asterisks. 
That is, given a <code class="language-plaintext highlighter-rouge">Point</code> struct that implements <code class="language-plaintext highlighter-rouge">Display</code> to result in <code class="language-plaintext highlighter-rouge">(x, y)</code>, when we call <code class="language-plaintext highlighter-rouge">outline_print</code> on a <code class="language-plaintext highlighter-rouge">Point</code> instance that has <code class="language-plaintext highlighter-rouge">1</code> for <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">3</code> for <code class="language-plaintext highlighter-rouge">y</code>, it should print the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>**********
*        *
* (1, 3) *
*        *
**********
</code></pre></div></div>

<p>In the implementation of <code class="language-plaintext highlighter-rouge">outline_print</code>, we want to use the <code class="language-plaintext highlighter-rouge">Display</code> trait’s functionality. 
Therefore, we need to specify that the <code class="language-plaintext highlighter-rouge">OutlinePrint</code> trait will work only for types that also implement <code class="language-plaintext highlighter-rouge">Display</code> and provide the functionality that <code class="language-plaintext highlighter-rouge">OutlinePrint</code> needs. 
We can do that in the trait definition by specifying <code class="language-plaintext highlighter-rouge">OutlinePrint: Display</code>. 
This technique is similar to adding a trait bound to the trait. 
Listing 19-22 shows an implementation of the <code class="language-plaintext highlighter-rouge">OutlinePrint</code> trait.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>

<span class="k">trait</span> <span class="n">OutlinePrint</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">outline_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.to_string</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">output</span><span class="nf">.len</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"*"</span><span class="nf">.repeat</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"*{}*"</span><span class="p">,</span> <span class="s">" "</span><span class="nf">.repeat</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"* {} *"</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"*{}*"</span><span class="p">,</span> <span class="s">" "</span><span class="nf">.repeat</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"*"</span><span class="nf">.repeat</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-22-implementing-the-outlineprint-trait-that-requires-the-functionality-from-display">Listing 19-22: Implementing the OutlinePrint trait that requires the functionality from Display</h4>
<p>Because we’ve specified that <code class="language-plaintext highlighter-rouge">OutlinePrint</code> requires the <code class="language-plaintext highlighter-rouge">Display</code> trait, we can use the <code class="language-plaintext highlighter-rouge">to_string</code> function that is automatically implemented for any type that implements <code class="language-plaintext highlighter-rouge">Display</code>. 
If we tried to use <code class="language-plaintext highlighter-rouge">to_string</code> without adding a colon and specifying the <code class="language-plaintext highlighter-rouge">Display</code> trait after the trait name, we’d get an error saying that no method named <code class="language-plaintext highlighter-rouge">to_string</code> was found for the type <code class="language-plaintext highlighter-rouge">&amp;Self</code> in the current scope.</p>

<p>Let’s see what happens when we try to implement <code class="language-plaintext highlighter-rouge">OutlinePrint</code> on a type that doesn’t implement <code class="language-plaintext highlighter-rouge">Display</code>, such as the <code class="language-plaintext highlighter-rouge">Point</code> struct:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">OutlinePrint</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{}</span>
</code></pre></div></div>
<p>We get an error saying that <code class="language-plaintext highlighter-rouge">Display</code> is required but not implemented:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">traits</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/traits-example)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]:</span> <span class="err">`</span><span class="n">Point</span><span class="err">`</span> <span class="n">doesn</span><span class="nv">'t</span> <span class="n">implement</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="err">`</span>
  <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mi">6</span>
   <span class="p">|</span>
<span class="mi">20</span> <span class="p">|</span> <span class="k">impl</span> <span class="n">OutlinePrint</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{}</span>
   <span class="p">|</span>      <span class="o">^^^^^^^^^^^^</span> <span class="err">`</span><span class="n">Point</span><span class="err">`</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">formatted</span> <span class="n">with</span> <span class="n">the</span> <span class="n">default</span> <span class="n">formatter</span>
   <span class="p">|</span>
   <span class="o">=</span> <span class="n">help</span><span class="p">:</span> <span class="n">the</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">implemented</span> <span class="k">for</span> <span class="err">`</span><span class="n">Point</span><span class="err">`</span>
   <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="k">in</span> <span class="n">format</span> <span class="n">strings</span> <span class="n">you</span> <span class="n">may</span> <span class="n">be</span> <span class="n">able</span> <span class="n">to</span> <span class="k">use</span> <span class="err">`</span><span class="p">{:</span><span class="o">?</span><span class="p">}</span><span class="err">`</span> <span class="p">(</span><span class="n">or</span> <span class="p">{:</span><span class="err">#</span><span class="o">?</span><span class="p">}</span> <span class="k">for</span> <span class="n">pretty</span><span class="o">-</span><span class="n">print</span><span class="p">)</span> <span class="n">instead</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0277</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">traits</span><span class="o">-</span><span class="n">example</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>To fix this, we implement <code class="language-plaintext highlighter-rouge">Display</code> on <code class="language-plaintext highlighter-rouge">Point</code> and satisfy the constraint that <code class="language-plaintext highlighter-rouge">OutlinePrint</code> requires, like so:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>

<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({}, {})"</span><span class="p">,</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span> <span class="k">self</span><span class="py">.y</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then implementing the <code class="language-plaintext highlighter-rouge">OutlinePrint</code> trait on <code class="language-plaintext highlighter-rouge">Point</code> will compile successfully, and we can call <code class="language-plaintext highlighter-rouge">outline_print</code> on a <code class="language-plaintext highlighter-rouge">Point</code> instance to display it within an outline of asterisks.</p>

<h3 id="using-the-newtype-pattern-to-implement-external-traits-on-external-types">Using the Newtype Pattern to Implement External Traits on External Types</h3>
<p>In Chapter 10 in the “Implementing a Trait on a Type” section, we mentioned the orphan rule that states we’re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. 
It’s possible to get around this restriction using the <em>newtype pattern</em>, which involves creating a new type in a tuple struct. 
(We covered tuple structs in the “Using Tuple Structs without Named Fields to Create Different Types” section of Chapter 5.) 
The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. 
Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. 
<em>Newtype</em> is a term that originates from the Haskell programming language. 
There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</p>

<p>As an example, let’s say we want to implement <code class="language-plaintext highlighter-rouge">Display</code> on <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>, which the orphan rule prevents us from doing directly because the <code class="language-plaintext highlighter-rouge">Display</code> trait and the <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> type are defined outside our crate. 
We can make a <code class="language-plaintext highlighter-rouge">Wrapper</code> struct that holds an instance of <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>; then we can implement <code class="language-plaintext highlighter-rouge">Display</code> on <code class="language-plaintext highlighter-rouge">Wrapper</code> and use the <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> value, as shown in Listing 19-23.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>

<span class="k">struct</span> <span class="nf">Wrapper</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Wrapper</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"[{}]"</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.join</span><span class="p">(</span><span class="s">", "</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="nf">Wrapper</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">),</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"world"</span><span class="p">)]);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"w = {}"</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-23-creating-a-wrapper-type-around-vec-to-implement-display">Listing 19-23: Creating a Wrapper type around Vec<String> to implement Display</String></h4>

<p>The implementation of <code class="language-plaintext highlighter-rouge">Display</code> uses <code class="language-plaintext highlighter-rouge">self.0</code> to access the inner <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>, because <code class="language-plaintext highlighter-rouge">Wrapper</code> is a tuple struct and <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> is the item at index 0 in the tuple. 
Then we can use the functionality of the <code class="language-plaintext highlighter-rouge">Display</code> type on <code class="language-plaintext highlighter-rouge">Wrapper</code>.</p>

<p>The downside of using this technique is that <code class="language-plaintext highlighter-rouge">Wrapper</code> is a new type, so it doesn’t have the methods of the value it’s holding. 
We would have to implement all the methods of <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> directly on <code class="language-plaintext highlighter-rouge">Wrapper</code> such that the methods delegate to <code class="language-plaintext highlighter-rouge">self.0</code>, which would allow us to treat <code class="language-plaintext highlighter-rouge">Wrapper</code> exactly like a <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>. 
If we wanted the new type to have every method the inner type has, implementing the <code class="language-plaintext highlighter-rouge">Deref</code> trait (discussed in Chapter 15 in the “Treating Smart Pointers Like Regular References with the Deref Trait” section) on the <code class="language-plaintext highlighter-rouge">Wrapper</code> to return the inner type would be a solution. 
If we don’t want the <code class="language-plaintext highlighter-rouge">Wrapper</code> type to have all the methods of the inner type—for example, to restrict the <code class="language-plaintext highlighter-rouge">Wrapper</code> type’s behavior—we would have to implement just the methods we do want manually.</p>

<p>Now you know how the newtype pattern is used in relation to traits; it’s also a useful pattern even when traits are not involved. Let’s switch focus and look at some advanced ways to interact with Rust’s type system.</p>

<h2 id="advanced-types">Advanced Types</h2>
<p>The Rust type system has some features that we’ve mentioned in this book but haven’t yet discussed. 
We’ll start by discussing newtypes in general as we examine why newtypes are useful as types. 
Then we’ll move on to type aliases, a feature similar to newtypes but with slightly different semantics. 
We’ll also discuss the <code class="language-plaintext highlighter-rouge">!</code> type and dynamically sized types.</p>

<p class="notice--info"><strong>Note</strong>: The next section assumes you’ve read the earlier section “Using the Newtype Pattern to Implement External Traits on External Types.”</p>

<h3 id="using-the-newtype-pattern-for-type-safety-and-abstraction">Using the Newtype Pattern for Type Safety and Abstraction</h3>
<p>The newtype pattern is useful for tasks beyond those we’ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value. 
You saw an example of using newtypes to indicate units in Listing 19-15: recall that the <code class="language-plaintext highlighter-rouge">Millimeters</code> and <code class="language-plaintext highlighter-rouge">Meters</code> structs wrapped <code class="language-plaintext highlighter-rouge">u32</code> values in a newtype. 
If we wrote a function with a parameter of type <code class="language-plaintext highlighter-rouge">Millimeters</code>, we couldn’t compile a program that accidentally tried to call that function with a value of type <code class="language-plaintext highlighter-rouge">Meters</code> or a plain <code class="language-plaintext highlighter-rouge">u32</code>.</p>

<p>Another use of the newtype pattern is in abstracting away some implementation details of a type: the new type can expose a public API that is different from the API of the private inner type if we used the new type directly to restrict the available functionality, for example.</p>

<p>Newtypes can also hide internal implementation. 
For example, we could provide a <code class="language-plaintext highlighter-rouge">People</code> type to wrap a <code class="language-plaintext highlighter-rouge">HashMap&lt;i32, String&gt;</code> that stores a person’s ID associated with their name. 
Code using <code class="language-plaintext highlighter-rouge">People</code> would only interact with the public API we provide, such as a method to add a name string to the <code class="language-plaintext highlighter-rouge">People</code> collection; that code wouldn’t need to know that we assign an <code class="language-plaintext highlighter-rouge">i32</code> ID to names internally. 
The newtype pattern is a lightweight way to achieve encapsulation to hide implementation details, which we discussed in the “Encapsulation that Hides Implementation Details” section of Chapter 17.</p>

<h3 id="creating-type-synonyms-with-type-aliases">Creating Type Synonyms with Type Aliases</h3>
<p>Along with the newtype pattern, Rust provides the ability to declare a <em>type alias</em> to give an existing type another name. 
For this we use the <code class="language-plaintext highlighter-rouge">type</code> keyword. 
For example, we can create the alias <code class="language-plaintext highlighter-rouge">Kilometers</code> to <code class="language-plaintext highlighter-rouge">i32</code> like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">type</span> <span class="n">Kilometers</span> <span class="o">=</span> <span class="nb">i32</span><span class="p">;</span>
</code></pre></div></div>

<p>Now, the alias <code class="language-plaintext highlighter-rouge">Kilometers</code> is a <strong>synonym</strong> for <code class="language-plaintext highlighter-rouge">i32</code>; unlike the <code class="language-plaintext highlighter-rouge">Millimeters</code> and <code class="language-plaintext highlighter-rouge">Meters</code> types we created in Listing 19-15, <code class="language-plaintext highlighter-rouge">Kilometers</code> is not a separate, new type. 
Values that have the type <code class="language-plaintext highlighter-rouge">Kilometers</code> will be treated the same as values of type <code class="language-plaintext highlighter-rouge">i32</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">type</span> <span class="n">Kilometers</span> <span class="o">=</span> <span class="nb">i32</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span><span class="p">:</span> <span class="n">Kilometers</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"x + y = {}"</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div></div>
<p>Because <code class="language-plaintext highlighter-rouge">Kilometers</code> and <code class="language-plaintext highlighter-rouge">i32</code> are the same type, we can add values of both types and we can pass <code class="language-plaintext highlighter-rouge">Kilometers</code> values to functions that take i32 parameters. 
However, using this method, we don’t get the type checking benefits that we get from the newtype pattern discussed earlier.</p>

<p>The main use case for type synonyms is to reduce repetition. For example, we might have a lengthy type like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>Writing this lengthy type in function signatures and as type annotations all over the code can be tiresome and error prone. 
Imagine having a project full of code like that in Listing 19-24.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">f</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"hi"</span><span class="p">));</span>

    <span class="k">fn</span> <span class="nf">takes_long_type</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// --snip--</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">returns_long_type</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// --snip--</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-24-using-a-long-type-in-many-places">Listing 19-24: Using a long type in many places</h4>

<p>A type alias makes this code more manageable by reducing the repetition. In Listing 19-25, we’ve introduced an alias named <code class="language-plaintext highlighter-rouge">Thunk</code> for the verbose type and can replace all uses of the type with the shorter alias <code class="language-plaintext highlighter-rouge">Thunk</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">type</span> <span class="n">Thunk</span> <span class="o">=</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">f</span><span class="p">:</span> <span class="n">Thunk</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"hi"</span><span class="p">));</span>

    <span class="k">fn</span> <span class="nf">takes_long_type</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Thunk</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// --snip--</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">returns_long_type</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Thunk</span> <span class="p">{</span>
        <span class="c1">// --snip--</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-25-introducing-a-type-alias-thunk-to-reduce-repetition">Listing 19-25: Introducing a type alias Thunk to reduce repetition</h4>
<p>This code is much easier to read and write! Choosing a meaningful name for a type alias can help communicate your intent as well (<em>thunk</em> is a word for code to be evaluated at a later time, so it’s an appropriate name for a closure that gets stored).</p>

<p>Type aliases are also commonly used with the <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code> type for reducing repetition. 
Consider the <code class="language-plaintext highlighter-rouge">std::io</code> module in the standard library. 
I/O operations often return a <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code> to handle situations when operations fail to work. 
This library has a <code class="language-plaintext highlighter-rouge">std::io::Error</code> struct that represents all possible I/O errors. 
Many of the functions in <code class="language-plaintext highlighter-rouge">std::io</code> will be returning <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code> where the <code class="language-plaintext highlighter-rouge">E</code> is <code class="language-plaintext highlighter-rouge">std::io::Error</code>, such as these functions in the Write trait:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">Write</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">write_fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Arguments</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">Result&lt;..., Error&gt;</code> is repeated a lot. As such, <code class="language-plaintext highlighter-rouge">std::io</code> has this type of alias declaration:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>
<p>Because this declaration is in the <code class="language-plaintext highlighter-rouge">std::io</code> module, we can use the fully qualified alias <code class="language-plaintext highlighter-rouge">std::io::Result&lt;T&gt;</code>—that is, a <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code> with the E filled in as <code class="language-plaintext highlighter-rouge">std::io::Error</code>. 
The Write trait function signatures end up looking like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Write</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">write_fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Arguments</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The type alias helps in two ways: it makes code easier to write <em>and</em> it gives us a consistent interface across all of <code class="language-plaintext highlighter-rouge">std::io</code>. 
Because it’s an alias, it’s just another <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code>, which means we can use any methods that work on <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code> with it, as well as special syntax like the <code class="language-plaintext highlighter-rouge">?</code> operator.</p>

<h3 id="the-never-type-that-never-returns">The Never Type that Never Returns</h3>
<p>Rust has a special type named <code class="language-plaintext highlighter-rouge">!</code> that’s known in type theory lingo as the <strong>empty</strong> type because it has no values. 
We prefer to call it the <em>never type</em> because it stands in the place of the return type when a function will never return. Here is an example:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">!</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This code is read as “the function <code class="language-plaintext highlighter-rouge">bar</code> returns never.” Functions that return never are called <em>diverging functions</em>. 
We can’t create values of the type <code class="language-plaintext highlighter-rouge">!</code> so <code class="language-plaintext highlighter-rouge">bar</code> can never possibly return.</p>

<p>But what use is a type you can never create values for? Recall the code from Listing 2-5; we’ve reproduced part of it here in Listing 19-26.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">let</span> <span class="n">guess</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="k">match</span> <span class="n">guess</span><span class="nf">.trim</span><span class="p">()</span><span class="nf">.parse</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">num</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>
        <span class="p">};</span>
</code></pre></div></div>
<h4 id="listing-19-26-a-match-with-an-arm-that-ends-in-continue">Listing 19-26: A match with an arm that ends in continue</h4>

<p>At the time, we skipped over some details in this code. 
In Chapter 6 in “The <code class="language-plaintext highlighter-rouge">match</code> Control Flow Operator” section, we discussed that <code class="language-plaintext highlighter-rouge">match</code> arms must all return the same type. 
So, for example, the following code doesn’t work:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">guess</span> <span class="o">=</span> <span class="k">match</span> <span class="n">guess</span><span class="nf">.trim</span><span class="p">()</span><span class="nf">.parse</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="mi">5</span><span class="p">,</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="s">"hello"</span><span class="p">,</span>
    <span class="p">};</span>
</code></pre></div></div>
<p>The type of <code class="language-plaintext highlighter-rouge">guess</code> in this code would have to be an integer <em>and</em> a string, and Rust requires that <code class="language-plaintext highlighter-rouge">guess</code> have only one type. 
So what does <code class="language-plaintext highlighter-rouge">continue</code> return? How were we allowed to return a <code class="language-plaintext highlighter-rouge">u32</code> from one arm and have another arm that ends with <code class="language-plaintext highlighter-rouge">continue</code> in Listing 19-26?</p>

<p>As you might have guessed, <code class="language-plaintext highlighter-rouge">continue</code> has a <code class="language-plaintext highlighter-rouge">!</code> value. 
That is, when Rust computes the type of <code class="language-plaintext highlighter-rouge">guess</code>, it looks at both match arms, the former with a value of <code class="language-plaintext highlighter-rouge">u32</code> and the latter with a <code class="language-plaintext highlighter-rouge">!</code> value. 
Because <code class="language-plaintext highlighter-rouge">!</code> can never have a value, Rust decides that the type of <code class="language-plaintext highlighter-rouge">guess</code> is <code class="language-plaintext highlighter-rouge">u32</code>.</p>

<p>The formal way of describing this behavior is that expressions of type <code class="language-plaintext highlighter-rouge">!</code> can be coerced into any other type. 
We’re allowed to end this <code class="language-plaintext highlighter-rouge">match</code> arm with <code class="language-plaintext highlighter-rouge">continue</code> because <code class="language-plaintext highlighter-rouge">continue</code> doesn’t return a value; instead, it moves control back to the top of the loop, so in the <code class="language-plaintext highlighter-rouge">Err</code> case, we never assign a value to <code class="language-plaintext highlighter-rouge">guess</code>.</p>

<p>The never type is useful with the <code class="language-plaintext highlighter-rouge">panic!</code> macro as well. 
Remember the <code class="language-plaintext highlighter-rouge">unwrap</code> function that we call on <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> values to produce a value or panic? Here is its definition:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">unwrap</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">val</span><span class="p">,</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"called `Option::unwrap()` on a `None` value"</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In this code, the same thing happens as in the <code class="language-plaintext highlighter-rouge">match</code> in Listing 19-26: Rust sees that <code class="language-plaintext highlighter-rouge">val</code> has the type <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">panic!</code> has the type <code class="language-plaintext highlighter-rouge">!</code>, so the result of the overall <code class="language-plaintext highlighter-rouge">match</code> expression is <code class="language-plaintext highlighter-rouge">T</code>. 
This code works because <code class="language-plaintext highlighter-rouge">panic!</code> doesn’t produce a value; it ends the program. 
In the <code class="language-plaintext highlighter-rouge">None</code> case, we won’t be returning a value from <code class="language-plaintext highlighter-rouge">unwrap</code>, so this code is valid.</p>

<p>One final expression that has the type <code class="language-plaintext highlighter-rouge">!</code> is a <code class="language-plaintext highlighter-rouge">loop</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">print!</span><span class="p">(</span><span class="s">"forever "</span><span class="p">);</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nd">print!</span><span class="p">(</span><span class="s">"and ever "</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>Here, the loop never ends, so <code class="language-plaintext highlighter-rouge">!</code> is the value of the expression. 
However, this wouldn’t be true if we included a <code class="language-plaintext highlighter-rouge">break</code>, because the loop would terminate when it got to the <code class="language-plaintext highlighter-rouge">break</code>.</p>

<h3 id="dynamically-sized-types-and-the-sized-trait">Dynamically Sized Types and the Sized Trait</h3>
<p>Due to Rust’s need to know certain details, such as how much space to allocate for a value of a particular type, there is a corner of its type system that can be confusing: the concept of <em>dynamically sized types</em>. 
Sometimes referred to as DSTs or <em>unsized types</em>, these types let us write code using values whose size we can know only at runtime.</p>

<p>Let’s dig into the details of a dynamically sized type called <code class="language-plaintext highlighter-rouge">str</code>, which we’ve been using throughout the book. 
That’s right, not <code class="language-plaintext highlighter-rouge">&amp;str</code>, but <code class="language-plaintext highlighter-rouge">str</code> on its own, is a DST. 
We can’t know how long the string is until runtime, meaning we can’t create a variable of type <code class="language-plaintext highlighter-rouge">str</code>, nor can we take an argument of type <code class="language-plaintext highlighter-rouge">str</code>. 
Consider the following code, which does not work:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">s1</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"Hello there!"</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"How's it going?"</span><span class="p">;</span>
</code></pre></div></div>
<p>Rust needs to know how much memory to allocate for any value of a particular type, and all values of a type must use the same amount of memory. 
If Rust allowed us to write this code, these two <code class="language-plaintext highlighter-rouge">str</code> values would need to take up the same amount of space. 
But they have different lengths: <code class="language-plaintext highlighter-rouge">s1</code> needs 12 bytes of storage and <code class="language-plaintext highlighter-rouge">s2</code> needs 15. 
This is why it’s not possible to create a variable holding a dynamically sized type.</p>

<p>So what do we do? In this case, you already know the answer: we make the types of <code class="language-plaintext highlighter-rouge">s1</code> and <code class="language-plaintext highlighter-rouge">s2</code> a <code class="language-plaintext highlighter-rouge">&amp;str</code> rather than a <code class="language-plaintext highlighter-rouge">str</code>. 
Recall that in the “String Slices” section of Chapter 4, we said the slice data structure stores the starting position and the length of the slice.</p>

<p>So although a <code class="language-plaintext highlighter-rouge">&amp;T</code> is a single value that stores the memory address of where the <code class="language-plaintext highlighter-rouge">T</code> is located, a <code class="language-plaintext highlighter-rouge">&amp;str</code> is <em>two</em> values: the address of the <code class="language-plaintext highlighter-rouge">str</code> and its length. 
As such, we can know the size of a <code class="language-plaintext highlighter-rouge">&amp;str</code> value at compile time: it’s twice the length of a <code class="language-plaintext highlighter-rouge">usize</code>. 
That is, we always know the size of a <code class="language-plaintext highlighter-rouge">&amp;str</code>, no matter how long the string it refers to is. 
In general, this is the way in which dynamically sized types are used in Rust: they have an extra bit of metadata that stores the size of the dynamic information. 
The golden rule of dynamically sized types is that we must always put values of dynamically sized types behind a pointer of some kind.</p>

<p>We can combine <code class="language-plaintext highlighter-rouge">str</code> with all kinds of pointers: for example, <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> or <code class="language-plaintext highlighter-rouge">Rc&lt;str&gt;</code>. 
In fact, you’ve seen this before but with a different dynamically sized type: traits. 
Every trait is a dynamically sized type we can refer to by using the name of the trait. 
In Chapter 17 in the “Using Trait Objects That Allow for Values of Different Types” section, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as <code class="language-plaintext highlighter-rouge">&amp;dyn Trait</code> or <code class="language-plaintext highlighter-rouge">Box&lt;dyn Trait&gt;</code> (<code class="language-plaintext highlighter-rouge">Rc&lt;dyn Trait&gt;</code> would work too).</p>

<p>To work with DSTs, Rust has a particular trait called the <code class="language-plaintext highlighter-rouge">Sized</code> trait to determine whether or not a type’s size is known at compile time. 
This trait is automatically implemented for everything whose size is known at compile time. 
In addition, Rust implicitly adds a bound on <code class="language-plaintext highlighter-rouge">Sized</code> to every generic function. 
That is, a generic function definition like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
<span class="p">}</span>
</code></pre></div></div>

<p>is actually treated as though we had written this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
<span class="p">}</span>
</code></pre></div></div>
<p>By default, generic functions will work only on types that have a known size at compile time. 
However, you can use the following special syntax to relax this restriction:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
<span class="p">}</span>
</code></pre></div></div>
<p>A trait bound on <code class="language-plaintext highlighter-rouge">?Sized</code> is the opposite of a trait bound on <code class="language-plaintext highlighter-rouge">Sized</code>: we would read this as “<code class="language-plaintext highlighter-rouge">T</code> may or may not be <code class="language-plaintext highlighter-rouge">Sized</code>.” This syntax is only available for <code class="language-plaintext highlighter-rouge">Sized</code>, not any other traits.</p>

<p>Also note that we switched the type of the <code class="language-plaintext highlighter-rouge">t</code> parameter from <code class="language-plaintext highlighter-rouge">T</code> to <code class="language-plaintext highlighter-rouge">&amp;T</code>. 
Because the type might not be Size<code class="language-plaintext highlighter-rouge">d</code>, we need to use it behind some kind of pointer. In this case, we’ve chosen a reference.</p>

<p>Next, we’ll talk about functions and closures!</p>

<h2 id="advanced-functions-and-closures">Advanced Functions and Closures</h2>
<p>Next, we’ll explore some advanced features related to functions and closures, which include function pointers and returning closures.</p>

<h3 id="function-pointers">Function Pointers</h3>
<p>We’ve talked about how to pass closures to functions; you can also pass regular functions to functions! 
This technique is useful when you want to pass a function you’ve already defined rather than defining a new closure. 
Doing this with function pointers will allow you to use functions as arguments to other functions. 
Functions coerce to the type <code class="language-plaintext highlighter-rouge">fn</code> (with a lowercase f), not to be confused with the <code class="language-plaintext highlighter-rouge">Fn</code> closure trait. 
The <code class="language-plaintext highlighter-rouge">fn</code> type is called a function pointer. The syntax for specifying that a parameter is a function pointer is similar to that of closures, as shown in Listing 19-27.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">answer</span> <span class="o">=</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">add_one</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"The answer is: {}"</span><span class="p">,</span> <span class="n">answer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-27-using-the-fn-type-to-accept-a-function-pointer-as-an-argument">Listing 19-27: Using the fn type to accept a function pointer as an argument</h4>

<p>This code prints <code class="language-plaintext highlighter-rouge">The answer is: 12</code>. 
We specify that the parameter <code class="language-plaintext highlighter-rouge">f</code> in <code class="language-plaintext highlighter-rouge">do_twice</code> is an <code class="language-plaintext highlighter-rouge">fn</code> that takes one parameter of type <code class="language-plaintext highlighter-rouge">i32</code> and returns an <code class="language-plaintext highlighter-rouge">i32</code>. 
We can then call <code class="language-plaintext highlighter-rouge">f</code> in the body of <code class="language-plaintext highlighter-rouge">do_twice</code>. 
In <code class="language-plaintext highlighter-rouge">main</code>, we can pass the function name <code class="language-plaintext highlighter-rouge">add_one</code> as the first argument to <code class="language-plaintext highlighter-rouge">do_twice</code>.</p>

<p>Unlike closures, <code class="language-plaintext highlighter-rouge">fn</code> is a type rather than a trait, so we specify <code class="language-plaintext highlighter-rouge">fn</code> as the parameter type directly rather than declaring a generic type parameter with one of the <code class="language-plaintext highlighter-rouge">Fn</code> traits as a trait bound.</p>

<p>Function pointers implement all three of the closure traits (<code class="language-plaintext highlighter-rouge">Fn</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, and <code class="language-plaintext highlighter-rouge">FnOnce</code>), so you can always pass a function pointer as an argument for a function that expects a closure. 
It’s best to write functions using a generic type and one of the closure traits so your functions can accept either functions or closures.</p>

<p>An example of where you would want to only accept <code class="language-plaintext highlighter-rouge">fn</code> and not closures is when interfacing with external code that doesn’t have closures: C functions can accept functions as arguments, but C doesn’t have closures.</p>

<p>As an example of where you could use either a closure defined inline or a named function, let’s look at a use of <code class="language-plaintext highlighter-rouge">map</code>. 
To use the <code class="language-plaintext highlighter-rouge">map</code> function to turn a vector of numbers into a vector of strings, we could use a closure, like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">list_of_numbers</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
    <span class="k">let</span> <span class="n">list_of_strings</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span>
        <span class="n">list_of_numbers</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.collect</span><span class="p">();</span>
</code></pre></div></div>
<p>Or we could name a function as the argument to <code class="language-plaintext highlighter-rouge">map</code> instead of the closure, like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">list_of_numbers</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
    <span class="k">let</span> <span class="n">list_of_strings</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span>
        <span class="n">list_of_numbers</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="nn">ToString</span><span class="p">::</span><span class="n">to_string</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
</code></pre></div></div>

<p>Note that we must use the fully qualified syntax that we talked about earlier in the “Advanced Traits” section because there are multiple functions available named <code class="language-plaintext highlighter-rouge">to_string</code>. 
Here, we’re using the <code class="language-plaintext highlighter-rouge">to_string</code> function defined in the <code class="language-plaintext highlighter-rouge">ToString</code> trait, which the standard library has implemented for any type that implements <code class="language-plaintext highlighter-rouge">Display</code>.</p>

<p>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants. 
These types use <code class="language-plaintext highlighter-rouge">()</code> as initializer syntax, which looks like a function call. 
The initializers are actually implemented as functions returning an instance that’s constructed from their arguments. 
We can use these initializer functions as function pointers that implement the closure traits, which means we can specify the initializer functions as arguments for methods that take closures, like so:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">enum</span> <span class="n">Status</span> <span class="p">{</span>
        <span class="nf">Value</span><span class="p">(</span><span class="nb">u32</span><span class="p">),</span>
        <span class="n">Stop</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">list_of_statuses</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Status</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0u32</span><span class="o">..</span><span class="mi">20</span><span class="p">)</span><span class="nf">.map</span><span class="p">(</span><span class="nn">Status</span><span class="p">::</span><span class="n">Value</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
</code></pre></div></div>
<p>Here we create <code class="language-plaintext highlighter-rouge">Status::Value</code> instances using each <code class="language-plaintext highlighter-rouge">u32</code> value in the range that <code class="language-plaintext highlighter-rouge">map</code> is called on by using the initializer function of <code class="language-plaintext highlighter-rouge">Status::Value</code>. 
Some people prefer this style, and some people prefer to use closures. 
They compile to the same code, so use whichever style is clearer to you.</p>

<h3 id="returning-closures">Returning Closures</h3>
<p>Closures are represented by traits, which means you can’t return closures directly. 
In most cases where you might want to return a trait, you can instead use the concrete type that implements the trait as the return value of the function. 
But you can’t do that with closures because they don’t have a concrete type that is returnable; you’re not allowed to use the function pointer <code class="language-plaintext highlighter-rouge">fn</code> as a return type, for example.</p>

<p>The following code tries to return a closure directly, but it won’t compile:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">returns_closure</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The compiler error is as follows:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">build</span>
   <span class="n">Compiling</span> <span class="n">functions</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/functions-example)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]:</span> <span class="n">the</span> <span class="n">size</span> <span class="k">for</span> <span class="n">values</span> <span class="n">of</span> <span class="k">type</span> <span class="err">`</span><span class="p">(</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="o">+</span> <span class="k">'static</span><span class="p">)</span><span class="err">`</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">known</span> <span class="n">at</span> <span class="n">compilation</span> <span class="n">time</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">lib</span><span class="py">.rs</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">25</span>
  <span class="p">|</span>
<span class="mi">1</span> <span class="p">|</span> <span class="k">fn</span> <span class="nf">returns_closure</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="p">|</span>                         <span class="o">^^^^^^^^^^^^^^^^^^</span> <span class="n">doesn</span><span class="nv">'t</span> <span class="n">have</span> <span class="n">a</span> <span class="n">size</span> <span class="n">known</span> <span class="n">at</span> <span class="n">compile</span><span class="o">-</span><span class="n">time</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">help</span><span class="p">:</span> <span class="n">the</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="nb">Sized</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">implemented</span> <span class="k">for</span> <span class="err">`</span><span class="p">(</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="o">+</span> <span class="k">'static</span><span class="p">)</span><span class="err">`</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">to</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">visit</span> <span class="o">&lt;</span><span class="n">https</span><span class="p">:</span><span class="c1">//doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">the</span> <span class="k">return</span> <span class="k">type</span> <span class="n">of</span> <span class="n">a</span> <span class="n">function</span> <span class="n">must</span> <span class="n">have</span> <span class="n">a</span> <span class="n">statically</span> <span class="n">known</span> <span class="n">size</span>

<span class="n">error</span><span class="p">[</span><span class="n">E0308</span><span class="p">]:</span> <span class="n">mismatched</span> <span class="n">types</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">lib</span><span class="py">.rs</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span>
  <span class="p">|</span>
<span class="mi">1</span> <span class="p">|</span> <span class="k">fn</span> <span class="nf">returns_closure</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="p">|</span>                         <span class="o">------------------</span> <span class="n">expected</span> <span class="err">`</span><span class="p">(</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="o">+</span> <span class="k">'static</span><span class="p">)</span><span class="err">`</span> <span class="n">because</span> <span class="n">of</span> <span class="k">return</span> <span class="k">type</span>
<span class="mi">2</span> <span class="p">|</span>     <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">|</span>     <span class="o">^^^^^^^^^</span> <span class="n">expected</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nb">Fn</span><span class="err">`</span><span class="p">,</span> <span class="n">found</span> <span class="n">closure</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">expected</span> <span class="k">trait</span> <span class="n">object</span> <span class="err">`</span><span class="p">(</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="o">+</span> <span class="k">'static</span><span class="p">)</span><span class="err">`</span>
                  <span class="n">found</span> <span class="n">closure</span> <span class="err">`</span><span class="p">[</span><span class="n">closure</span><span class="o">@</span><span class="n">src</span><span class="o">/</span><span class="n">lib</span><span class="py">.rs</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="mi">2</span><span class="p">:</span><span class="mi">14</span><span class="p">]</span><span class="err">`</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="mi">2</span> <span class="n">previous</span> <span class="n">errors</span>

<span class="nb">Some</span> <span class="n">errors</span> <span class="n">have</span> <span class="n">detailed</span> <span class="n">explanations</span><span class="p">:</span> <span class="n">E0277</span><span class="p">,</span> <span class="n">E0308</span><span class="py">.
For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">an</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0277</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">functions</span><span class="o">-</span><span class="n">example</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>The error references the <code class="language-plaintext highlighter-rouge">Sized</code> trait again! Rust doesn’t know how much space it will need to store the closure. We saw a solution to this problem earlier. 
We can use a trait object:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">returns_closure</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This code will compile just fine. For more about trait objects, refer to the section “Using Trait Objects That Allow for Values of Different Types” in Chapter 17.</p>

<p>Next, let’s look at macros!</p>

<h2 id="macros">Macros</h2>
<p>We’ve used macros like <code class="language-plaintext highlighter-rouge">println!</code> throughout this book, but we haven’t fully explored what a macro is and how it works. 
The term <em>macro</em> refers to a family of features in Rust: <em>declarative</em> macros with <code class="language-plaintext highlighter-rouge">macro_rules!</code> and three kinds of <em>procedural</em> macros:</p>

<ul>
  <li>Custom #[derive] macros that specify code added with the derive attribute used on structs and enums</li>
  <li>Attribute-like macros that define custom attributes usable on any item</li>
  <li>Function-like macros that look like function calls but operate on the tokens specified as their argument</li>
</ul>

<p>We’ll talk about each of these in turn, but first, let’s look at why we even need macros when we already have functions.</p>

<h3 id="the-difference-between-macros-and-functions">The Difference Between Macros and Functions</h3>
<p>Fundamentally, macros are a way of writing code that writes other code, which is known as <em>metaprogramming</em>. 
In Appendix C, we discuss the <code class="language-plaintext highlighter-rouge">derive</code> attribute, which generates an implementation of various traits for you. We’ve also used the <code class="language-plaintext highlighter-rouge">println!</code> and <code class="language-plaintext highlighter-rouge">vec!</code> macros throughout the book. 
All of these macros <em>expand</em> to produce more code than the code you’ve written manually.</p>

<p>Metaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions. 
However, macros have some additional powers that functions don’t.</p>

<p>A function signature must declare the number and type of parameters the function has. 
Macros, on the other hand, can take a variable number of parameters: we can call <code class="language-plaintext highlighter-rouge">println!("hello")</code> with one argument or <code class="language-plaintext highlighter-rouge">println!("hello {}", name)</code> with two arguments. 
Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. 
A function can’t, because it gets called at runtime and a trait needs to be implemented at compile time.</p>

<p>The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you’re writing Rust code that writes Rust code. 
Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</p>

<p>Another important difference between macros and functions is that you must define macros or bring them into scope <em>before</em> you call them in a file, as opposed to functions you can define anywhere and call anywhere.</p>

<h3 id="declarative-macros-with-macro_rules-for-general-metaprogramming">Declarative Macros with macro_rules! for General Metaprogramming</h3>
<p>The most widely used form of macros in Rust is <em>declarative</em> macros. 
These are also sometimes referred to as “macros by example,” “<code class="language-plaintext highlighter-rouge">macro_rules!</code> macros,” or just plain “macros.” 
At their core, declarative macros allow you to write something similar to a Rust <code class="language-plaintext highlighter-rouge">match</code> expression. 
As discussed in Chapter 6, <code class="language-plaintext highlighter-rouge">match</code> expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. 
Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. 
This all happens during compilation.</p>

<p>To define a macro, you use the <code class="language-plaintext highlighter-rouge">macro_rules!</code> construct. 
Let’s explore how to use <code class="language-plaintext highlighter-rouge">macro_rules!</code> by looking at how the <code class="language-plaintext highlighter-rouge">vec!</code> macro is defined. 
Chapter 8 covered how we can use the <code class="language-plaintext highlighter-rouge">vec!</code> macro to create a new vector with particular values. 
For example, the following macro creates a new vector containing three integers:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</code></pre></div></div>
<p>We could also use the <code class="language-plaintext highlighter-rouge">vec!</code> macro to make a vector of two integers or a vector of five string slices. 
We wouldn’t be able to use a function to do the same because we wouldn’t know the number or type of values up front.</p>

<p>Listing 19-28 shows a slightly simplified definition of the <code class="language-plaintext highlighter-rouge">vec!</code> macro.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">vec</span> <span class="p">{</span>
    <span class="p">(</span> <span class="nv">$</span><span class="p">(</span> <span class="nv">$x:expr</span> <span class="p">),</span><span class="o">*</span> <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">temp_vec</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="n">temp_vec</span><span class="nf">.push</span><span class="p">(</span><span class="nv">$x</span><span class="p">);</span>
            <span class="p">)</span><span class="o">*</span>
            <span class="n">temp_vec</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-28-a-simplified-version-of-the-vec-macro-definition">Listing 19-28: A simplified version of the vec! macro definition</h4>

<p class="notice--info">Note: The actual definition of the <code class="language-plaintext highlighter-rouge">vec!</code> macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don’t include here to make the example simpler.</p>

<p>The <code class="language-plaintext highlighter-rouge">#[macro_export]</code> annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. 
Without this annotation, the macro can’t be brought into scope.</p>

<p>We then start the macro definition with <code class="language-plaintext highlighter-rouge">macro_rules!</code> and the name of the macro we’re defining <em>without</em> the exclamation mark. 
The name, in this case <code class="language-plaintext highlighter-rouge">vec</code>, is followed by curly brackets denoting the body of the macro definition.</p>

<p>The structure in the <code class="language-plaintext highlighter-rouge">vec!</code> body is similar to the structure of a <code class="language-plaintext highlighter-rouge">match</code> expression. 
Here we have one arm with the pattern <code class="language-plaintext highlighter-rouge">( $( $x:expr ),* )</code>, followed by <code class="language-plaintext highlighter-rouge">=&gt;</code> and the block of code associated with this pattern. 
If the pattern matches, the associated block of code will be emitted. 
Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. 
More complex macros will have more than one arm.</p>

<p>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. 
Let’s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see <a href="https://doc.rust-lang.org/reference/macros-by-example.html">the reference</a>.</p>

<p>First, a set of parentheses encompasses the whole pattern. 
A dollar sign (<code class="language-plaintext highlighter-rouge">$</code>) is next, followed by a set of parentheses that captures values that match the pattern within the parentheses for use in the replacement code. 
Within <code class="language-plaintext highlighter-rouge">$()</code> is <code class="language-plaintext highlighter-rouge">$x:expr</code>, which matches any Rust expression and gives the expression the name <code class="language-plaintext highlighter-rouge">$x</code>.</p>

<p>The comma following <code class="language-plaintext highlighter-rouge">$()</code> indicates that a literal comma separator character could optionally appear after the code that matches the code in <code class="language-plaintext highlighter-rouge">$()</code>. 
The <code class="language-plaintext highlighter-rouge">*</code> specifies that the pattern matches zero or more of whatever precedes the <code class="language-plaintext highlighter-rouge">*</code>.</p>

<p>When we call this macro with <code class="language-plaintext highlighter-rouge">vec![1, 2, 3]</code>;, the <code class="language-plaintext highlighter-rouge">$x</code> pattern matches three times with the three expressions <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, and <code class="language-plaintext highlighter-rouge">3</code>.</p>

<p>Now let’s look at the pattern in the body of the code associated with this arm: <code class="language-plaintext highlighter-rouge">temp_vec.push()</code> within <code class="language-plaintext highlighter-rouge">$()*</code> is generated for each part that matches <code class="language-plaintext highlighter-rouge">$()</code> in the pattern zero or more times depending on how many times the pattern matches. 
The <code class="language-plaintext highlighter-rouge">$x</code> is replaced with each expression matched. When we call this macro with <code class="language-plaintext highlighter-rouge">vec![1, 2, 3];</code>, the code generated that replaces this macro call will be the following:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">temp_vec</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">temp_vec</span><span class="nf">.push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">temp_vec</span><span class="nf">.push</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">temp_vec</span><span class="nf">.push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">temp_vec</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We’ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.</p>

<p>There are some strange edge cases with <code class="language-plaintext highlighter-rouge">macro_rules!</code>. 
In the future, Rust will have a second kind of declarative macro that will work in a similar fashion but fix some of these edge cases. 
After that update, <code class="language-plaintext highlighter-rouge">macro_rules!</code> will be effectively deprecated. 
With this in mind, as well as the fact that most Rust programmers will use macros more than write macros, we won’t discuss <code class="language-plaintext highlighter-rouge">macro_rules!</code> any further. 
To learn more about how to write macros, consult the online documentation or other resources, such as “The Little Book of Rust Macros”.</p>

<h3 id="procedural-macros-for-generating-code-from-attributes">Procedural Macros for Generating Code from Attributes</h3>
<p>The second form of macros is <em>procedural macros</em>, which act more like functions (and are a type of procedure). 
Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.</p>

<p>The three kinds of procedural macros (custom derive, attribute-like, and function-like) all work in a similar fashion.</p>

<p>When creating procedural macros, the definitions must reside in their own crate with a special crate type. 
This is for complex technical reasons that we hope to eliminate in the future. 
Using procedural macros looks like the code in Listing 19-29, where <code class="language-plaintext highlighter-rouge">some_attribute</code> is a placeholder for using a specific macro.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">use</span> <span class="n">proc_macro</span><span class="p">;</span>

<span class="nd">#[some_attribute]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">some_name</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-29-an-example-of-using-a-procedural-macro">Listing 19-29: An example of using a procedural macro</h4>
<p>The function that defines a procedural macro takes a <code class="language-plaintext highlighter-rouge">TokenStream</code> as an input and produces a <code class="language-plaintext highlighter-rouge">TokenStream</code> as an output. 
The <code class="language-plaintext highlighter-rouge">TokenStream</code> type is defined by the <code class="language-plaintext highlighter-rouge">proc_macro</code> crate that is included with Rust and represents a sequence of tokens. 
This is the core of the macro: the source code that the macro is operating on makes up the input <code class="language-plaintext highlighter-rouge">TokenStream</code>, and the code the macro produces is the output <code class="language-plaintext highlighter-rouge">TokenStream</code>. 
The function also has an attribute attached to it that specifies which kind of procedural macro we’re creating. 
We can have multiple kinds of procedural macros in the same crate.</p>

<p>Let’s look at the different kinds of procedural macros. We’ll start with a custom derive macro and then explain the small dissimilarities that make the other forms different.</p>

<h3 id="how-to-write-a-custom-derive-macro">How to Write a Custom derive Macro</h3>
<p>Let’s create a crate named <code class="language-plaintext highlighter-rouge">hello_macro</code> that defines a trait named <code class="language-plaintext highlighter-rouge">HelloMacro</code> with one associated function named <code class="language-plaintext highlighter-rouge">hello_macro</code>. 
Rather than making our crate users implement the <code class="language-plaintext highlighter-rouge">HelloMacro</code> trait for each of their types, we’ll provide a procedural macro so users can annotate their type with <code class="language-plaintext highlighter-rouge">#[derive(HelloMacro)]</code> to get a default implementation of the <code class="language-plaintext highlighter-rouge">hello_macro</code> function. 
The default implementation will print <code class="language-plaintext highlighter-rouge">Hello, Macro! My name is TypeName!</code> where <code class="language-plaintext highlighter-rouge">TypeName</code> is the name of the type on which this trait has been defined. 
In other words, we’ll write a crate that enables another programmer to write code like Listing 19-30 using our crate.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">hello_macro</span><span class="p">::</span><span class="n">HelloMacro</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">hello_macro_derive</span><span class="p">::</span><span class="n">HelloMacro</span><span class="p">;</span>

<span class="nd">#[derive(HelloMacro)]</span>
<span class="k">struct</span> <span class="n">Pancakes</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">Pancakes</span><span class="p">::</span><span class="nf">hello_macro</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-30-the-code-a-user-of-our-crate-will-be-able-to-write-when-using-our-procedural-macro">Listing 19-30: The code a user of our crate will be able to write when using our procedural macro</h4>

<p>This code will print <code class="language-plaintext highlighter-rouge">Hello, Macro! My name is Pancakes!</code> when we’re done. 
The first step is to make a new library crate, like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cargo new hello_macro --lib
</code></pre></div></div>
<p>Next, we’ll define the <code class="language-plaintext highlighter-rouge">HelloMacro</code> trait and its associated function:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">HelloMacro</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">hello_macro</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">hello_macro</span><span class="p">::</span><span class="n">HelloMacro</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Pancakes</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">HelloMacro</span> <span class="k">for</span> <span class="n">Pancakes</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">hello_macro</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, Macro! My name is Pancakes!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">Pancakes</span><span class="p">::</span><span class="nf">hello_macro</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<p>However, they would need to write the implementation block for each type they wanted to use with <code class="language-plaintext highlighter-rouge">hello_macro</code>; we want to spare them from having to do this work.</p>

<p>Additionally, we can’t yet provide the <code class="language-plaintext highlighter-rouge">hello_macro</code> function with default implementation that will print the name of the type the trait is implemented on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s name at runtime. 
We need a macro to generate code at compile time.</p>

<p>The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. 
Eventually, this restriction might be lifted. 
The convention for structuring crates and macro crates is as follows: for a crate named <code class="language-plaintext highlighter-rouge">foo</code>, a custom derive procedural macro crate is called <code class="language-plaintext highlighter-rouge">foo_derive</code>. 
Let’s start a new crate called <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> inside our <code class="language-plaintext highlighter-rouge">hello_macro</code> project:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cargo new hello_macro_derive --lib
</code></pre></div></div>

<p>Our two crates are tightly related, so we create the procedural macro crate within the directory of our <code class="language-plaintext highlighter-rouge">hello_macro</code> crate. 
If we change the trait definition in <code class="language-plaintext highlighter-rouge">hello_macro</code>, we’ll have to change the implementation of the procedural macro in <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> as well. 
The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope. 
We could instead have the <code class="language-plaintext highlighter-rouge">hello_macro</code> crate use <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> as a dependency and re-export the procedural macro code. 
However, the way we’ve structured the project makes it possible for programmers to use <code class="language-plaintext highlighter-rouge">hello_macro</code> even if they don’t want the <code class="language-plaintext highlighter-rouge">derive</code> functionality.</p>

<p>We need to declare the <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> crate as a procedural macro crate. 
We’ll also need functionality from the <code class="language-plaintext highlighter-rouge">syn</code> and <code class="language-plaintext highlighter-rouge">quote</code> crates, as you’ll see in a moment, so we need to add them as dependencies. Add the following to the <em>Cargo.toml</em> file for <code class="language-plaintext highlighter-rouge">hello_macro_derive</code>:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: hello_macro_derive/Cargo.toml</span>

<span class="p">[</span><span class="n">lib</span><span class="p">]</span>
<span class="n">proc</span><span class="o">-</span><span class="k">macro</span> <span class="o">=</span> <span class="k">true</span>

<span class="p">[</span><span class="n">dependencies</span><span class="p">]</span>
<span class="n">syn</span> <span class="o">=</span> <span class="s">"1.0"</span>
<span class="n">quote</span> <span class="o">=</span> <span class="s">"1.0"</span>
</code></pre></div></div>
<p>To start defining the procedural macro, place the code in Listing 19-31 into your <em>src/lib.rs</em> file for the <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> crate. 
Note that this code won’t compile until we add a definition for the <code class="language-plaintext highlighter-rouge">impl_hello_macro</code> function.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: hello_macro_derive/src/lib.rs</span>

<span class="k">extern</span> <span class="k">crate</span> <span class="n">proc_macro</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">quote</span><span class="p">::</span><span class="n">quote</span><span class="p">;</span>
<span class="k">use</span> <span class="n">syn</span><span class="p">;</span>

<span class="nd">#[proc_macro_derive(HelloMacro)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">hello_macro_derive</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
    <span class="c1">// Construct a representation of Rust code as a syntax tree</span>
    <span class="c1">// that we can manipulate</span>
    <span class="k">let</span> <span class="n">ast</span> <span class="o">=</span> <span class="nn">syn</span><span class="p">::</span><span class="nf">parse</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="c1">// Build the trait implementation</span>
    <span class="nf">impl_hello_macro</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ast</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-31-code-that-most-procedural-macro-crates-will-require-in-order-to-process-rust-code">Listing 19-31: Code that most procedural macro crates will require in order to process Rust code</h4>

<p>Notice that we’ve split the code into the <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> function, which is responsible for parsing the <code class="language-plaintext highlighter-rouge">TokenStream</code>, and the <code class="language-plaintext highlighter-rouge">impl_hello_macro</code> function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (<code class="language-plaintext highlighter-rouge">hello_macro_derive</code> in this case) will be the same for almost every procedural macro crate you see or create. 
The code you specify in the body of the inner function (<code class="language-plaintext highlighter-rouge">impl_hello_macro</code> in this case) will be different depending on your procedural macro’s purpose.</p>

<p>We’ve introduced three new crates: <code class="language-plaintext highlighter-rouge">proc_macro</code>, <code class="language-plaintext highlighter-rouge">syn</code>, and <code class="language-plaintext highlighter-rouge">quote</code>. 
The <code class="language-plaintext highlighter-rouge">proc_macro</code> crate comes with Rust, so we didn’t need to add that to the dependencies in <em>Cargo.toml</em>. 
The <code class="language-plaintext highlighter-rouge">proc_macro</code> crate is the compiler’s API that allows us to read and manipulate Rust code from our code.</p>

<p>The <code class="language-plaintext highlighter-rouge">syn</code> crate parses Rust code from a string into a data structure that we can perform operations on. 
The <code class="language-plaintext highlighter-rouge">quote</code> crate turns <code class="language-plaintext highlighter-rouge">syn</code> data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.</p>

<p>The <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> function will be called when a user of our library specifies <code class="language-plaintext highlighter-rouge">#[derive(HelloMacro)]</code> on a type. 
This is possible because we’ve annotated the <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> function here with <code class="language-plaintext highlighter-rouge">proc_macro_derive</code> and specified the name, <code class="language-plaintext highlighter-rouge">HelloMacro</code>, which matches our trait name; this is the convention most procedural macros follow.</p>

<p>The <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> function first converts the <code class="language-plaintext highlighter-rouge">input</code> from a <code class="language-plaintext highlighter-rouge">TokenStream</code> to a data structure that we can then interpret and perform operations on. 
This is where <code class="language-plaintext highlighter-rouge">syn</code> comes into play. 
The <code class="language-plaintext highlighter-rouge">parse</code> function in <code class="language-plaintext highlighter-rouge">syn</code> takes a TokenStream and returns a <code class="language-plaintext highlighter-rouge">DeriveInput</code> struct representing the parsed Rust code. 
Listing 19-32 shows the relevant parts of the <code class="language-plaintext highlighter-rouge">DeriveInput</code> struct we get from parsing the <code class="language-plaintext highlighter-rouge">struct Pancakes;</code> string:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DeriveInput</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>

    <span class="n">ident</span><span class="p">:</span> <span class="n">Ident</span> <span class="p">{</span>
        <span class="n">ident</span><span class="p">:</span> <span class="s">"Pancakes"</span><span class="p">,</span>
        <span class="n">span</span><span class="p">:</span> <span class="err">#</span><span class="mi">0</span> <span class="nf">bytes</span><span class="p">(</span><span class="mi">95</span><span class="o">..</span><span class="mi">103</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="n">data</span><span class="p">:</span> <span class="nf">Struct</span><span class="p">(</span>
        <span class="n">DataStruct</span> <span class="p">{</span>
            <span class="n">struct_token</span><span class="p">:</span> <span class="n">Struct</span><span class="p">,</span>
            <span class="n">fields</span><span class="p">:</span> <span class="n">Unit</span><span class="p">,</span>
            <span class="n">semi_token</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span>
                <span class="n">Semi</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Listing 19-32: The DeriveInput instance we get when parsing the code that has the macro’s attribute in Listing 19-30</p>

<p>The fields of this struct show that the Rust code we’ve parsed is a unit struct with the <code class="language-plaintext highlighter-rouge">ident</code> (identifier, meaning the name) of <code class="language-plaintext highlighter-rouge">Pancakes</code>. 
There are more fields on this struct for describing all sorts of Rust code; check the <code class="language-plaintext highlighter-rouge">syn</code> documentation for <code class="language-plaintext highlighter-rouge">DeriveInput</code> for more information.</p>

<p>Soon we’ll define the <code class="language-plaintext highlighter-rouge">impl_hello_macro</code> function, which is where we’ll build the new Rust code we want to include. 
But before we do, note that the output for our derive macro is also a <code class="language-plaintext highlighter-rouge">TokenStream</code>. 
The returned <code class="language-plaintext highlighter-rouge">TokenStream</code> is added to the code that our crate users write, so when they compile their crate, they’ll get the extra functionality that we provide in the modified <code class="language-plaintext highlighter-rouge">TokenStream</code>.</p>

<p>You might have noticed that we’re calling <code class="language-plaintext highlighter-rouge">unwrap</code> to cause the <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> function to panic if the call to the <code class="language-plaintext highlighter-rouge">syn::parse</code> function fails here. 
It’s necessary for our procedural macro to panic on errors because <code class="language-plaintext highlighter-rouge">proc_macro_derive</code> functions must return <code class="language-plaintext highlighter-rouge">TokenStream</code> rather than <code class="language-plaintext highlighter-rouge">Result</code> to conform to the procedural macro API. 
We’ve simplified this example by using <code class="language-plaintext highlighter-rouge">unwrap</code>; in production code, you should provide more specific error messages about what went wrong by using <code class="language-plaintext highlighter-rouge">panic!</code> or <code class="language-plaintext highlighter-rouge">expect</code>.</p>

<p>Now that we have the code to turn the annotated Rust code from a <code class="language-plaintext highlighter-rouge">TokenStream</code> into a <code class="language-plaintext highlighter-rouge">DeriveInput</code> instance, let’s generate the code that implements the <code class="language-plaintext highlighter-rouge">HelloMacro</code> trait on the annotated type, as shown in Listing 19-33.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: hello_macro_derive/src/lib.rs</span>

<span class="k">fn</span> <span class="nf">impl_hello_macro</span><span class="p">(</span><span class="n">ast</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">syn</span><span class="p">::</span><span class="n">DeriveInput</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ast</span><span class="py">.ident</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">gen</span> <span class="o">=</span> <span class="nd">quote!</span> <span class="p">{</span>
        <span class="k">impl</span> <span class="n">HelloMacro</span> <span class="k">for</span> #<span class="n">name</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">hello_macro</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, Macro! My name is {}!"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span>#<span class="n">name</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">gen</span><span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-33-implementing-the-hellomacro-trait-using-the-parsed-rust-code">Listing 19-33: Implementing the HelloMacro trait using the parsed Rust code</h4>

<p>We get an <code class="language-plaintext highlighter-rouge">Ident</code> struct instance containing the name (identifier) of the annotated type using <code class="language-plaintext highlighter-rouge">ast.ident</code>. 
The struct in Listing 19-32 shows that when we run the <code class="language-plaintext highlighter-rouge">impl_hello_macro</code> function on the code in Listing 19-30, the <code class="language-plaintext highlighter-rouge">ident</code> we get will have the <code class="language-plaintext highlighter-rouge">ident</code> field with a value of <code class="language-plaintext highlighter-rouge">"Pancakes"</code>. 
Thus, the <code class="language-plaintext highlighter-rouge">name</code> variable in Listing 19-33 will contain an <code class="language-plaintext highlighter-rouge">Ident</code> struct instance that, when printed, will be the string <code class="language-plaintext highlighter-rouge">"Pancakes"</code>, the name of the struct in Listing 19-30.</p>

<p>The <code class="language-plaintext highlighter-rouge">quote!</code> macro lets us define the Rust code that we want to return. 
The compiler expects something different to the direct result of the <code class="language-plaintext highlighter-rouge">quote!</code> macro’s execution, so we need to convert it to a <code class="language-plaintext highlighter-rouge">TokenStream</code>. 
We do this by calling the <code class="language-plaintext highlighter-rouge">into</code> method, which consumes this intermediate representation and returns a value of the required <code class="language-plaintext highlighter-rouge">TokenStream</code> type.</p>

<p>The <code class="language-plaintext highlighter-rouge">quote!</code> macro also provides some very cool templating mechanics: we can enter <code class="language-plaintext highlighter-rouge">#name</code>, and <code class="language-plaintext highlighter-rouge">quote!</code> will replace it with the value in the variable name. 
You can even do some repetition similar to the way regular macros work. 
Check out <a href="https://docs.rs/quote/1.0.8/quote/">the <code class="language-plaintext highlighter-rouge">quote</code> crate’s docs</a> for a thorough introduction.</p>

<p>We want our procedural macro to generate an implementation of our <code class="language-plaintext highlighter-rouge">HelloMacro</code> trait for the type the user annotated, which we can get by using <code class="language-plaintext highlighter-rouge">#name</code>. 
The trait implementation has one function, <code class="language-plaintext highlighter-rouge">hello_macro</code>, whose body contains the functionality we want to provide: printing <code class="language-plaintext highlighter-rouge">Hello, Macro! My name</code> is and then the name of the annotated type.</p>

<p>The <code class="language-plaintext highlighter-rouge">stringify!</code> macro used here is built into Rust. 
It takes a Rust expression, such as <code class="language-plaintext highlighter-rouge">1 + 2</code>, and at compile time turns the expression into a string literal, such as <code class="language-plaintext highlighter-rouge">"1 + 2"</code>. 
This is different than <code class="language-plaintext highlighter-rouge">format!</code> or <code class="language-plaintext highlighter-rouge">println!</code>, macros which evaluate the expression and then turn the result into a <code class="language-plaintext highlighter-rouge">String</code>. 
There is a possibility that the <code class="language-plaintext highlighter-rouge">#name</code> input might be an expression to print literally, so we use <code class="language-plaintext highlighter-rouge">stringify!</code>. 
Using <code class="language-plaintext highlighter-rouge">stringify!</code> also saves an allocation by converting <code class="language-plaintext highlighter-rouge">#name</code> to a string literal at compile time.</p>

<p>At this point, <code class="language-plaintext highlighter-rouge">cargo build</code> should complete successfully in both <code class="language-plaintext highlighter-rouge">hello_macro</code> and <code class="language-plaintext highlighter-rouge">hello_macro_derive</code>. 
Let’s hook up these crates to the code in Listing 19-30 to see the procedural macro in action! Create a new binary project in your <em>projects</em> directory using cargo new pancakes. 
We need to add <code class="language-plaintext highlighter-rouge">hello_macro</code> and <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> as dependencies in the <code class="language-plaintext highlighter-rouge">pancakes</code> crate’s <em>Cargo.toml</em>. 
If you’re publishing your versions of <code class="language-plaintext highlighter-rouge">hello_macro</code> and <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> to <a href="https://crates.io/">crates.io</a>, they would be regular dependencies; if not, you can specify them as <code class="language-plaintext highlighter-rouge">path</code> dependencies as follows:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">dependencies</span><span class="p">]</span>
<span class="n">hello_macro</span> <span class="o">=</span> <span class="p">{</span> <span class="n">path</span> <span class="o">=</span> <span class="s">"../hello_macro"</span> <span class="p">}</span>
<span class="n">hello_macro_derive</span> <span class="o">=</span> <span class="p">{</span> <span class="n">path</span> <span class="o">=</span> <span class="s">"../hello_macro/hello_macro_derive"</span> <span class="p">}</span>
</code></pre></div></div>
<p>Put the code in Listing 19-30 into <em>src/main.rs</em>, and run <code class="language-plaintext highlighter-rouge">cargo run</code>: it should print <code class="language-plaintext highlighter-rouge">Hello, Macro! My name is Pancakes!</code> The implementation of the <code class="language-plaintext highlighter-rouge">HelloMacro</code> trait from the procedural macro was included without the <code class="language-plaintext highlighter-rouge">pancakes</code> crate needing to implement it; the <code class="language-plaintext highlighter-rouge">#[derive(HelloMacro)]</code> added the trait implementation.</p>

<p>Next, let’s explore how the other kinds of procedural macros differ from custom derive macros.</p>

<h3 id="attribute-like-macros">Attribute-like macros</h3>
<p>Attribute-like macros are similar to custom derive macros, but instead of generating code for the <code class="language-plaintext highlighter-rouge">derive</code> attribute, they allow you to create new attributes. 
They’re also more flexible: <code class="language-plaintext highlighter-rouge">derive</code> only works for structs and enums; attributes can be applied to other items as well, such as functions. 
Here’s an example of using an attribute-like macro: say you have an attribute named <code class="language-plaintext highlighter-rouge">route</code> that annotates functions when using a web application framework:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[route(GET,</span> <span class="s">"/"</span><span class="nd">)]</span>
<span class="k">fn</span> <span class="nf">index</span><span class="p">()</span> <span class="p">{</span>
</code></pre></div></div>
<p>This <code class="language-plaintext highlighter-rouge">#[route]</code> attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[proc_macro_attribute]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">route</span><span class="p">(</span><span class="n">attr</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
</code></pre></div></div>
<p>Here, we have two parameters of type <code class="language-plaintext highlighter-rouge">TokenStream</code>. 
The first is for the contents of the attribute: the <code class="language-plaintext highlighter-rouge">GET, "/"</code> part. 
The second is the body of the item the attribute is attached to: in this case, <code class="language-plaintext highlighter-rouge">fn index() {}</code> and the rest of the function’s body.</p>

<p>Other than that, attribute-like macros work the same way as custom derive macros: you create a crate with the <code class="language-plaintext highlighter-rouge">proc-macro</code> crate type and implement a function that generates the code you want!</p>

<h3 id="function-like-macros">Function-like macros</h3>
<p>Function-like macros define macros that look like function calls. 
Similarly to <code class="language-plaintext highlighter-rouge">macro_rules!</code> macros, they’re more flexible than functions; 
for example, they can take an unknown number of arguments. 
However, <code class="language-plaintext highlighter-rouge">macro_rules!</code> macros can be defined only using the match-like syntax we discussed in the section “Declarative Macros with <code class="language-plaintext highlighter-rouge">macro_rules!</code> for General Metaprogramming” earlier. 
Function-like macros take a <code class="language-plaintext highlighter-rouge">TokenStream</code> parameter and their definition manipulates that <code class="language-plaintext highlighter-rouge">TokenStream</code> using Rust code as the other two types of procedural macros do. 
An example of a function-like macro is an <code class="language-plaintext highlighter-rouge">sql!</code> macro that might be called like so:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">sql</span> <span class="o">=</span> <span class="nd">sql!</span><span class="p">(</span><span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">posts</span> <span class="n">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>
<p>This macro would parse the SQL statement inside it and check that it’s syntactically correct, which is much more complex processing than a <code class="language-plaintext highlighter-rouge">macro_rules!</code> macro can do. 
The <code class="language-plaintext highlighter-rouge">sql!</code> macro would be defined like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[proc_macro]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sql</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
</code></pre></div></div>
<p>This definition is similar to the custom derive macro’s signature: we receive the tokens that are inside the parentheses and return the code we wanted to generate.</p>

<h2 id="summary">Summary</h2>
<p>Whew! Now you have some Rust features in your toolbox that you won’t use often, but you’ll know they’re available in very particular circumstances. 
We’ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples’ code, you’ll be able to recognize these concepts and syntax. 
Use this chapter as a reference to guide you to solutions.</p>

<p>Next, we’ll put everything we’ve discussed throughout the book into practice and do one more project!</p>]]></content><author><name>JJungs-lee</name></author><category term="RUST Language" /><category term="Unsafe" /><category term="Advanced traits" /><category term="Advanced types" /><category term="Advanced functions" /><category term="closures" /><category term="macro" /><summary type="html"><![CDATA[Advanced Features By now, you’ve learned the most commonly used parts of the Rust programming language. Before we do one more project in Chapter 20, we’ll look at a few aspects of the language you might run into every once in a while. You can use this chapter as a reference for when you encounter any unknowns when using Rust. The features you’ll learn to use in this chapter are useful in very specific situations. Although you might not reach for them often, we want to make sure you have a grasp of all the features Rust has to offer.]]></summary></entry></feed>