var store = [{
        "title": "RUST : 3.Common Programming Concepts",
        "excerpt":"Variables and Mutability     Default variables are immutable.  If you want mutable variable, can make them mutable by adding mut in front of the variable name.     fn main() {     let mut x = 5;     println!(\"The value of x is: {}\", x);     x = 6;     println!(\"The value of x is: {}\", x); }          First, you aren‚Äôt allowed to use mut with constants. Constants aren‚Äôt just immutable by default‚Äîthey‚Äôre always immutable.  You declare constants using the const keyword instead of the let keyword, and the type of the value must be annotated.      const MAX_POINTS: u32 = 100_000;          Note: Rust‚Äôs naming convention for constants is to use all uppercase with underscores between words, and underscores can be inserted in numeric literals to improve readability       Data Types          Keep in mind that Rust is a statically typed language, which means that it must know the types of all variables at compile time.       Table 3-1: Integer Types in Rust                                  Length           Signed           Unsigned                                           8-bit           i8           u8                             16-bit           i16           u16                             32-bit           i32           u32                             64-bit           i64           u64                             arch           isize           usize                           Table 3-2:Integer Literals in Rust                                  Number literals           Example                                           Decimal           98_222                             Hex           0xff                             Octal           0o77                             Binary           0b1111_0000                             Byte (u8 only)           b‚ÄôA‚Äô                           // Floating-Point(default type is f64) let x = 2.0; // f64 let y: f32 = 3.0; // f32  // Numeric Operations let sum = 5 + 10; let difference = 95.5 - 4.3; let product = 4 * 30; let quotient = 56.7 / 32.2; let remainder = 43 % 5;  // Boolean let t = true; let f: bool = false; // with explicit type annotation  // Character let c = 'z'; let z = '‚Ñ§'; let heart_eyed_cat = 'üòª';  // Tuple let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\"The value of y is: {}\", y);  // Access a tuple element directly by using a period(.) // followed by the index of the value we want to access let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2;  // array let a = [1, 2, 3, 4, 5]; let first = a[0]; let second = a[1];           Functions     fn keyword, which allows you to declare new functions.  Rust doesn‚Äôt care where you define your functions, only that they‚Äôre defined somewhere.     fn main() {     println!(\"Hello, world!\");      another_function(); }  fn another_function() {     println!(\"Another function.\"); }          Parameters      fn main() {   another_function(5, 6); }  fn another_function(x: i32, y: i32) {   println!(\"The value of x is: {}\", x);   println!(\"The value of y is: {}\", y); }           Function Bodies Contain Statements and Expressions      Statements are instructions that perform some action and do not return a value.   Expressions evaluate to a resulting value.      fn main() {   let y = 6;  // This is Statemnets    // Error - (let y = 6) statement does not return a value   let x = (let y = 6);  }          Note: This is different from what happens in other languages, such as C and Ruby, where the assignment returns the value of the assignment.  In those languages, you can write x = y = 6 and have both x and y have the value 6; that is not the case in Rust.       Expressions can be part of statements: the 6 in the statement let y = 6; is an expression that evaluates to the value 6.  Calling a function is an expression. Calling a macro is an expression. The block that we use to create new scopes, {}, is an expression, for example:      fn main() {   let x = 5;    let y = { //like this       let x = 3;       x + 1   };    println!(\"The value of y is: {}\", y); }          This expression:      {   let x = 3;   x + 1 }          Note: the x + 1 line without a semicolon at the end, which is unlike most of the lines you‚Äôve seen so far.  Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value. Keep this in mind as you explore function return values and expressions next.       Functions with Return Values      We don‚Äôt name return values, but we do declare their type after an arrow (-&gt;) In Rust, the return value of the function is synonymous with the value of the final expression in the block of the body of a function.  You can return early from a function by using the return keyword and specifying a value, but most functions return the last expression implicitly.      // perfectly valid function in Rust fn five() -&gt; i32 {   5   }  fn main() {   let x = five();    println!(\"The value of x is: {}\", x); }           fn main() {   let x = plus_one(5);    println!(\"The value of x is: {}\", x); }  fn plus_one(x: i32) -&gt; i32 {   x + 1   // If place a semicolon at the end of the line x + 1,   // changing it from an expression to a statement,    // we‚Äôll get an error.   // like this -&gt; error[E0308]: mismatched types }           Comments     A simple comment:     // So we‚Äôre doing something complicated here,  // long enough that we need // multiple lines of comments to do it! // Whew! Hopefully, this comment will // explain what‚Äôs going on. let lucky_number = 7; // I‚Äôm feeling lucky today.          Rust also has another kind of comment, documentation comments, which we‚Äôll discuss in the ‚ÄúPublishing a Crate to Crates.io‚Äù section of Chapter 14.      ","categories": ["RUST"],
        "tags": ["concepts","valriable"],
        "url": "https://jjungs-lee.github.io//rust/3.Common-Programming-Concepts/",
        "teaser":null},{
        "title": "RUST : Overview",
        "excerpt":"I will post a summary of RUST   Plz follow the below link. Thx :D nil   link     Getting Started   Programming a Guessing Game   3. Common Programming Concepts   Understanding Ownership   Using Structs to Structure Related Data   Enums and Pattern Matching   Managing Growing Projects with Packages, Crates, and Modules   Common Collections   Error Handling   Generic Types, Traits, and Lifetimes   Writing Automated Tests   An I/O Project: Building a Command Line Program   Functional Language Features: Iterators and Closures   More about Cargo and Crates.io   Smart Pointers   Fearless Concurrency   Object Oriented Programming Features of Rust   Patterns and Matching   Advanced Features   Final Project: Building a Multithreaded Web Server   Appendix    [Reference]   eng ver : https://doc.rust-lang.org/book/title-page.html   kor ver : https://rinthel.github.io/rust-lang-book-ko  ","categories": ["RUST"],
        "tags": ["Summery","Overview"],
        "url": "https://jjungs-lee.github.io//rust/rust_overview/",
        "teaser":null},]
